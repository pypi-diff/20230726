# Comparing `tmp/SC-Track-0.0.4.tar.gz` & `tmp/SC-Track-0.0.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "SC-Track-0.0.4.tar", last modified: Tue Jul  4 20:14:15 2023, max compression
+gzip compressed data, was "SC-Track-0.0.5.tar", last modified: Wed Jul 26 07:26:57 2023, max compression
```

## Comparing `SC-Track-0.0.4.tar` & `SC-Track-0.0.5.tar`

### file list

```diff
@@ -1,27 +1,27 @@
-drwxrwxrwx   0        0        0        0 2023-07-04 20:14:15.837305 SC-Track-0.0.4/
--rw-rw-rw-   0        0        0    35821 2023-07-03 22:48:32.000000 SC-Track-0.0.4/LICENSE
--rw-rw-rw-   0        0        0     4777 2023-07-04 20:14:15.837305 SC-Track-0.0.4/PKG-INFO
-drwxrwxrwx   0        0        0        0 2023-07-04 20:14:15.823291 SC-Track-0.0.4/SCTrack/
--rw-rw-rw-   0        0        0      179 2023-07-04 08:35:35.000000 SC-Track-0.0.4/SCTrack/__init__.py
--rw-rw-rw-   0        0        0    27194 2023-07-04 04:54:52.000000 SC-Track-0.0.4/SCTrack/base.py
--rw-rw-rw-   0        0        0      261 2023-07-03 20:41:40.000000 SC-Track-0.0.4/SCTrack/config.py
--rw-rw-rw-   0        0        0    15056 2023-07-04 04:56:48.000000 SC-Track-0.0.4/SCTrack/feature.py
--rw-rw-rw-   0        0        0     9503 2023-07-04 04:29:49.000000 SC-Track-0.0.4/SCTrack/generate_tracking_stack.py
--rw-rw-rw-   0        0        0     3711 2023-07-04 04:47:49.000000 SC-Track-0.0.4/SCTrack/prepare.py
--rw-rw-rw-   0        0        0    24004 2023-07-04 08:48:54.000000 SC-Track-0.0.4/SCTrack/reclassification.py
--rw-rw-rw-   0        0        0     3542 2023-07-04 08:51:09.000000 SC-Track-0.0.4/SCTrack/sctrack.py
--rw-rw-rw-   0        0        0     1666 2023-05-13 09:06:34.000000 SC-Track-0.0.4/SCTrack/t_error.py
--rw-rw-rw-   0        0        0      559 2023-06-30 14:38:42.000000 SC-Track-0.0.4/SCTrack/template.py
--rw-rw-rw-   0        0        0     1905 2023-07-04 04:29:49.000000 SC-Track-0.0.4/SCTrack/track.py
--rw-rw-rw-   0        0        0    54458 2023-07-04 04:39:08.000000 SC-Track-0.0.4/SCTrack/tracker.py
--rw-rw-rw-   0        0        0     7472 2023-07-04 05:21:39.000000 SC-Track-0.0.4/SCTrack/utils.py
-drwxrwxrwx   0        0        0        0 2023-07-04 20:14:15.835303 SC-Track-0.0.4/SC_Track.egg-info/
--rw-rw-rw-   0        0        0     4777 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      507 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       49 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0        2 2023-07-04 05:53:23.000000 SC-Track-0.0.4/SC_Track.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0      252 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/requires.txt
--rw-rw-rw-   0        0        0        8 2023-07-04 20:14:15.000000 SC-Track-0.0.4/SC_Track.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2023-07-04 20:14:15.837305 SC-Track-0.0.4/setup.cfg
--rw-rw-rw-   0        0        0     1000 2023-07-04 20:13:44.000000 SC-Track-0.0.4/setup.py
+drwxrwxrwx   0        0        0        0 2023-07-26 07:26:57.806866 SC-Track-0.0.5/
+-rw-rw-rw-   0        0        0    35821 2023-07-03 22:48:32.000000 SC-Track-0.0.5/LICENSE
+-rw-rw-rw-   0        0        0     5413 2023-07-26 07:26:57.806866 SC-Track-0.0.5/PKG-INFO
+drwxrwxrwx   0        0        0        0 2023-07-26 07:26:57.798859 SC-Track-0.0.5/SCTrack/
+-rw-rw-rw-   0        0        0      179 2023-07-04 08:35:35.000000 SC-Track-0.0.5/SCTrack/__init__.py
+-rw-rw-rw-   0        0        0    27248 2023-07-24 06:45:06.000000 SC-Track-0.0.5/SCTrack/base.py
+-rw-rw-rw-   0        0        0     1347 2023-07-26 07:03:32.000000 SC-Track-0.0.5/SCTrack/config.py
+-rw-rw-rw-   0        0        0    15310 2023-07-26 06:36:08.000000 SC-Track-0.0.5/SCTrack/feature.py
+-rw-rw-rw-   0        0        0     9503 2023-07-04 04:29:49.000000 SC-Track-0.0.5/SCTrack/generate_tracking_stack.py
+-rw-rw-rw-   0        0        0     3727 2023-07-05 11:28:13.000000 SC-Track-0.0.5/SCTrack/prepare.py
+-rw-rw-rw-   0        0        0    30160 2023-07-20 21:06:01.000000 SC-Track-0.0.5/SCTrack/reclassification.py
+-rw-rw-rw-   0        0        0     3675 2023-07-26 07:03:32.000000 SC-Track-0.0.5/SCTrack/sctrack.py
+-rw-rw-rw-   0        0        0     1683 2023-07-18 17:15:31.000000 SC-Track-0.0.5/SCTrack/t_error.py
+-rw-rw-rw-   0        0        0      563 2023-07-05 11:28:13.000000 SC-Track-0.0.5/SCTrack/template.py
+-rw-rw-rw-   0        0        0     2241 2023-07-24 14:36:01.000000 SC-Track-0.0.5/SCTrack/track.py
+-rw-rw-rw-   0        0        0    50418 2023-07-26 07:26:31.000000 SC-Track-0.0.5/SCTrack/tracker.py
+-rw-rw-rw-   0        0        0     7472 2023-07-04 05:21:39.000000 SC-Track-0.0.5/SCTrack/utils.py
+drwxrwxrwx   0        0        0        0 2023-07-26 07:26:57.805866 SC-Track-0.0.5/SC_Track.egg-info/
+-rw-rw-rw-   0        0        0     5413 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0      507 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       49 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/entry_points.txt
+-rw-rw-rw-   0        0        0        2 2023-07-04 05:53:23.000000 SC-Track-0.0.5/SC_Track.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0      252 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        8 2023-07-26 07:26:57.000000 SC-Track-0.0.5/SC_Track.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2023-07-26 07:26:57.806866 SC-Track-0.0.5/setup.cfg
+-rw-rw-rw-   0        0        0     1000 2023-07-18 18:07:00.000000 SC-Track-0.0.5/setup.py
```

### Comparing `SC-Track-0.0.4/LICENSE` & `SC-Track-0.0.5/LICENSE`

 * *Files identical despite different names*

### Comparing `SC-Track-0.0.4/PKG-INFO` & `SC-Track-0.0.5/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 00000000: 4d65 7461 6461 7461 2d56 6572 7369 6f6e  Metadata-Version
 00000010: 3a20 322e 310d 0a4e 616d 653a 2053 432d  : 2.1..Name: SC-
 00000020: 5472 6163 6b0d 0a56 6572 7369 6f6e 3a20  Track..Version: 
-00000030: 302e 302e 340d 0a53 756d 6d61 7279 3a20  0.0.4..Summary: 
+00000030: 302e 302e 350d 0a53 756d 6d61 7279 3a20  0.0.5..Summary: 
 00000040: 7369 6e67 6c65 2063 656c 6c20 7472 6163  single cell trac
 00000050: 6b69 6e67 2070 6163 6b61 6765 0d0a 486f  king package..Ho
 00000060: 6d65 2d70 6167 653a 2068 7474 7073 3a2f  me-page: https:/
 00000070: 2f67 6974 6875 622e 636f 6d2f 6672 6f7a  /github.com/froz
 00000080: 656e 6c65 6176 6573 2f53 432d 5472 6163  enleaves/SC-Trac
 00000090: 6b0d 0a41 7574 686f 723a 204c 6920 4368  k..Author: Li Ch
 000000a0: 656e 6778 696e 0d0a 4175 7468 6f72 2d65  engxin..Author-e
@@ -15,285 +15,325 @@
 000000e0: 6c69 6320 4c69 6365 6e73 6520 7633 2e30  lic License v3.0
 000000f0: 0d0a 5265 7175 6972 6573 2d50 7974 686f  ..Requires-Pytho
 00000100: 6e3a 203e 3d33 2e37 0d0a 4465 7363 7269  n: >=3.7..Descri
 00000110: 7074 696f 6e2d 436f 6e74 656e 742d 5479  ption-Content-Ty
 00000120: 7065 3a20 7465 7874 2f6d 6172 6b64 6f77  pe: text/markdow
 00000130: 6e0d 0a4c 6963 656e 7365 2d46 696c 653a  n..License-File:
 00000140: 204c 4943 454e 5345 0d0a 0d0a 0d0a 0d0a   LICENSE........
-00000150: 2323 2320 5768 6174 2773 2020 5343 2d54  ### What's  SC-T
-00000160: 7261 636b 3f0d 0a0d 0a0d 0a53 432d 5472  rack?......SC-Tr
-00000170: 6163 6b20 6973 2061 6e20 6566 6669 6369  ack is an effici
-00000180: 656e 7420 616c 676f 7269 7468 6d20 666f  ent algorithm fo
-00000190: 7220 6479 6e61 6d69 6320 7472 6163 6b69  r dynamic tracki
-000001a0: 6e67 206f 6620 7369 6e67 6c65 2063 656c  ng of single cel
-000001b0: 6c73 206f 6e20 6469 6666 6572 656e 7420  ls on different 
-000001c0: 7469 6d65 2d6c 6170 7365 206d 6963 726f  time-lapse micro
-000001d0: 7363 6f70 6520 696d 6167 6573 2e20 0d0a  scope images. ..
-000001e0: 4974 2063 616e 2075 7365 2074 6865 2073  It can use the s
-000001f0: 6567 6d65 6e74 6174 696f 6e20 7265 7375  egmentation resu
-00000200: 6c74 7320 6f66 2076 6172 696f 7573 206d  lts of various m
-00000210: 6f64 656c 7320 746f 2065 6666 6963 6965  odels to efficie
-00000220: 6e74 6c79 2074 7261 636b 2073 696e 676c  ntly track singl
-00000230: 6520 6365 6c6c 7320 616e 6420 7265 636f  e cells and reco
-00000240: 6e73 7472 7563 7420 6365 6c6c 206c 696e  nstruct cell lin
-00000250: 6573 2e20 0d0a 4974 2063 616e 2074 7261  es. ..It can tra
-00000260: 636b 206d 756c 7469 2d67 656e 6572 6174  ck multi-generat
-00000270: 696f 6e61 6c20 6365 6c6c 2064 6976 6973  ional cell divis
-00000280: 696f 6e20 6576 656e 7473 2077 6974 686f  ion events witho
-00000290: 7574 2061 6e79 2061 6464 6974 696f 6e61  ut any additiona
-000002a0: 6c20 696e 666f 726d 6174 696f 6e2c 206f  l information, o
-000002b0: 6e6c 7920 7573 696e 6720 7468 6520 6f75  nly using the ou
-000002c0: 746c 696e 6520 696e 666f 726d 6174 696f  tline informatio
-000002d0: 6e20 6f66 2063 656c 6c73 3b20 0d0a 616e  n of cells; ..an
-000002e0: 6420 6361 6e20 7265 6475 6365 2074 6865  d can reduce the
-000002f0: 206e 6f69 7365 206f 6620 7468 6520 7365   noise of the se
-00000300: 676d 656e 7461 7469 6f6e 2c20 736f 2061  gmentation, so a
-00000310: 7320 746f 2075 7365 2074 6865 206e 6f69  s to use the noi
-00000320: 7365 2073 6567 6d65 6e74 6174 696f 6e20  se segmentation 
-00000330: 7265 7375 6c74 7320 746f 2067 656e 6572  results to gener
-00000340: 6174 6520 6163 6375 7261 7465 2063 656c  ate accurate cel
-00000350: 6c20 6c69 6e65 6167 6573 2e20 0d0a 4974  l lineages. ..It
-00000360: 7320 6361 7363 6164 652d 6361 6368 696e  s cascade-cachin
-00000370: 6720 6d6f 6465 6c20 6361 6e20 6566 6669  g model can effi
-00000380: 6369 656e 746c 7920 6465 616c 2077 6974  ciently deal wit
-00000390: 6820 7365 676d 656e 7461 7469 6f6e 206c  h segmentation l
-000003a0: 6f73 732c 2061 6e64 2069 7473 2054 5053  oss, and its TPS
-000003b0: 2061 6c67 6f72 6974 686d 2063 616e 2070   algorithm can p
-000003c0: 6572 666f 726d 2061 6363 7572 6174 6520  erform accurate 
-000003d0: 7265 636c 6173 7369 6669 6361 7469 6f6e  reclassification
-000003e0: 200d 0a66 6f72 2075 7365 7273 2077 6974   ..for users wit
-000003f0: 6820 6365 6c6c 2063 6c61 7373 6966 6963  h cell classific
-00000400: 6174 696f 6e20 6e65 6564 7320 2873 7563  ation needs (suc
-00000410: 6820 6173 2063 6c61 7373 6966 6963 6174  h as classificat
-00000420: 696f 6e20 6f66 2064 6966 6665 7265 6e74  ion of different
-00000430: 2063 656c 6c20 6379 636c 6520 7068 6173   cell cycle phas
-00000440: 6573 292e 200d 0a53 432d 5472 6163 6b20  es). ..SC-Track 
-00000450: 616c 6c6f 7773 2075 7365 7273 2074 6f20  allows users to 
-00000460: 7573 6520 6469 6666 6572 656e 7420 7365  use different se
-00000470: 676d 656e 7461 7469 6f6e 2072 6573 756c  gmentation resul
-00000480: 7473 2061 7320 696e 7075 742c 2069 6e63  ts as input, inc
-00000490: 6c75 6469 6e67 2074 6865 204a 534f 4e20  luding the JSON 
-000004a0: 616e 6e6f 7461 7469 6f6e 2066 696c 6520  annotation file 
-000004b0: 666f 726d 6174 2073 7570 706f 7274 6564  format supported
-000004c0: 2062 7920 5647 4720 696d 6167 6520 616e   by VGG image an
-000004d0: 6e6f 7461 746f 722c 200d 0a61 6e64 2074  notator, ..and t
-000004e0: 6865 2063 6f6d 6d6f 6e20 6d61 736b 2067  he common mask g
-000004f0: 7261 7973 6361 6c65 2069 6d61 6765 2066  rayscale image f
-00000500: 6f72 6d61 742e 2054 6865 2065 7870 6f72  ormat. The expor
-00000510: 7420 7265 7375 6c74 7320 696e 636c 7564  t results includ
-00000520: 6520 7472 6163 6b20 7461 626c 652c 2076  e track table, v
-00000530: 6973 7561 6c69 7a65 6420 6c61 6265 6c65  isualized labele
-00000540: 6420 696d 6167 652c 200d 0a4a 534f 4e20  d image, ..JSON 
-00000550: 6669 6c65 2063 6f6e 7461 696e 696e 6720  file containing 
-00000560: 7472 6163 6b69 6e67 2069 6e66 6f72 6d61  tracking informa
-00000570: 7469 6f6e 2028 7768 6963 6820 6361 6e20  tion (which can 
-00000580: 6265 2069 6d70 6f72 7465 6420 696e 746f  be imported into
-00000590: 2056 4747 2069 6d61 6765 2061 6e6e 6f74   VGG image annot
-000005a0: 6174 6f72 2066 6f72 2076 6965 7769 6e67  ator for viewing
-000005b0: 292c 200d 0a61 6e64 2061 2063 6f6c 6c65  ), ..and a colle
-000005c0: 6374 696f 6e20 6f66 2054 7261 636b 696e  ction of Trackin
-000005d0: 6754 7265 6520 7374 7275 6374 7572 6520  gTree structure 
-000005e0: 7472 6565 2066 696c 6573 2e20 5573 6572  tree files. User
-000005f0: 7320 6361 6e20 7065 7266 6f72 6d20 6d6f  s can perform mo
-00000600: 7265 2064 6574 6169 6c65 6420 646f 776e  re detailed down
-00000610: 7374 7265 616d 2061 6e61 6c79 7369 7320  stream analysis 
-00000620: 6f6e 2074 6865 2074 7261 636b 2074 6162  on the track tab
-00000630: 6c65 2c20 0d0a 7669 6577 2074 6865 2074  le, ..view the t
-00000640: 7261 636b 696e 6720 7265 7375 6c74 7320  racking results 
-00000650: 7468 726f 7567 6820 7669 7375 616c 697a  through visualiz
-00000660: 6564 2072 6573 756c 7473 2c20 616e 6420  ed results, and 
-00000670: 6d6f 6469 6679 2074 6865 2074 7261 636b  modify the track
-00000680: 2074 6162 6c65 206f 7220 7472 6163 6b20   table or track 
-00000690: 6a73 6f6e 2066 696c 6520 746f 206d 616e  json file to man
-000006a0: 7561 6c6c 7920 636f 7272 6563 7420 7472  ually correct tr
-000006b0: 6163 6b69 6e67 2065 7272 6f72 732e 200d  acking errors. .
-000006c0: 0a53 432d 5472 6163 6b20 6973 206e 6f74  .SC-Track is not
-000006d0: 206f 6e6c 7920 7375 6974 6162 6c65 2066   only suitable f
-000006e0: 6f72 2073 6d61 6c6c 2074 696d 656c 6170  or small timelap
-000006f0: 7365 2061 6e61 6c79 7369 732c 2062 7574  se analysis, but
-00000700: 2061 6c73 6f20 7375 6974 6162 6c65 2066   also suitable f
-00000710: 6f72 206c 6f6e 6720 7469 6d65 2061 6e64  or long time and
-00000720: 2068 6967 6820 6365 6c6c 2064 656e 7369   high cell densi
-00000730: 7479 2074 696d 656c 6170 7365 2061 6e61  ty timelapse ana
-00000740: 6c79 7369 7320 6f66 2074 686f 7573 616e  lysis of thousan
-00000750: 6473 206f 6620 6672 616d 6573 2e0d 0a0d  ds of frames....
-00000760: 0a0d 0a0d 0a0d 0a23 2323 2057 6879 2075  .......### Why u
-00000770: 7369 6e67 2020 5343 2d54 7261 636b 3f0d  sing  SC-Track?.
-00000780: 0a0d 0a2d 2020 2054 6865 2063 7572 7265  ...-   The curre
-00000790: 6e74 206d 6169 6e73 7472 6561 6d20 6d65  nt mainstream me
-000007a0: 7468 6f64 7320 666f 7220 696d 6167 6520  thods for image 
-000007b0: 7365 676d 656e 7461 7469 6f6e 2061 6c6c  segmentation all
-000007c0: 2075 7365 2064 6565 7020 6c65 6172 6e69   use deep learni
-000007d0: 6e67 2c20 616e 6420 7468 6520 6f75 7470  ng, and the outp
-000007e0: 7574 2072 6573 756c 7473 2063 6f6e 7461  ut results conta
-000007f0: 696e 206e 6f69 7365 7320 6f66 2076 6172  in noises of var
-00000800: 7969 6e67 2069 6e74 656e 7369 7469 6573  ying intensities
-00000810: 2e20 5343 2d54 7261 636b 2069 7320 6375  . SC-Track is cu
-00000820: 7272 656e 746c 7920 7468 6520 6f6e 6c79  rrently the only
-00000830: 2061 6c67 6f72 6974 686d 2074 6861 7420   algorithm that 
-00000840: 6361 6e20 7573 6520 7468 6573 6520 6e6f  can use these no
-00000850: 6973 6520 6461 7461 2066 6f72 2061 6363  ise data for acc
-00000860: 7572 6174 6520 7369 6e67 6c65 2d63 656c  urate single-cel
-00000870: 6c20 7472 6163 6b69 6e67 2061 6e64 206c  l tracking and l
-00000880: 696e 6561 6765 2072 6563 6f6e 7374 7275  ineage reconstru
-00000890: 6374 696f 6e2e 0d0a 2d20 5343 2d54 7261  ction...- SC-Tra
-000008a0: 636b 2069 7320 636f 6d70 6174 6962 6c65  ck is compatible
-000008b0: 2077 6974 6820 7468 6520 6f75 7470 7574   with the output
-000008c0: 2072 6573 756c 7473 206f 6620 6d6f 7374   results of most
-000008d0: 206f 6620 7468 6520 6578 6973 7469 6e67   of the existing
-000008e0: 206d 6169 6e73 7472 6561 6d20 7365 676d   mainstream segm
-000008f0: 656e 7461 7469 6f6e 206d 6f64 656c 732c  entation models,
-00000900: 2061 7320 7765 6c6c 2061 7320 6d61 6e75   as well as manu
-00000910: 616c 2073 6567 6d65 6e74 6174 696f 6e20  al segmentation 
-00000920: 7265 7375 6c74 732c 2069 6e63 6c75 6469  results, includi
-00000930: 6e67 2043 656c 6c70 6f73 652c 2044 6565  ng Cellpose, Dee
-00000940: 7043 656c 6c2c 2053 7461 7264 6973 742c  pCell, Stardist,
-00000950: 2065 7463 2e20 5573 6572 7320 6361 6e20   etc. Users can 
-00000960: 6368 6f6f 7365 2061 206d 6f72 6520 6164  choose a more ad
-00000970: 7661 6e63 6564 2061 6e64 2073 7569 7461  vanced and suita
-00000980: 626c 6520 7365 676d 656e 7461 7469 6f6e  ble segmentation
-00000990: 206d 6f64 656c 2061 6363 6f72 6469 6e67   model according
-000009a0: 2074 6f20 7468 6520 6365 6c6c 2074 7970   to the cell typ
-000009b0: 6520 746f 2073 706c 6974 2e0d 0a2d 2053  e to split...- S
-000009c0: 432d 5472 6163 6b20 6361 6e20 6566 6669  C-Track can effi
-000009d0: 6369 656e 746c 7920 7472 6163 6b20 6d75  ciently track mu
-000009e0: 6c74 6970 6c65 2074 6172 6765 7473 2062  ltiple targets b
-000009f0: 6574 7765 656e 2066 7261 6d65 7320 7769  etween frames wi
-00000a00: 7468 6f75 7420 7265 6c79 696e 6720 6f6e  thout relying on
-00000a10: 2067 6c6f 6261 6c20 696e 666f 726d 6174   global informat
-00000a20: 696f 6e2c 2061 6e64 2063 616e 2062 6520  ion, and can be 
-00000a30: 7573 6564 2066 6f72 2072 6561 6c2d 7469  used for real-ti
-00000a40: 6d65 2074 7261 636b 696e 672e 0d0a 2d20  me tracking...- 
-00000a50: 5343 2d54 7261 636b 2069 7320 696d 706c  SC-Track is impl
-00000a60: 656d 656e 7465 6420 696e 2050 7974 686f  emented in Pytho
-00000a70: 6e2c 2077 6869 6368 2068 6173 2073 7472  n, which has str
-00000a80: 6f6e 6720 7363 616c 6162 696c 6974 792c  ong scalability,
-00000a90: 2063 6f6e 7665 6e69 656e 7420 616e 6420   convenient and 
-00000aa0: 7175 6963 6b20 696e 7374 616c 6c61 7469  quick installati
-00000ab0: 6f6e 2c20 616e 6420 6c6f 7720 6465 7065  on, and low depe
-00000ac0: 6e64 656e 6379 2e0d 0a0d 0a0d 0a0d 0a23  ndency.........#
-00000ad0: 2323 2048 6f77 2074 6f20 7573 6520 5343  ## How to use SC
-00000ae0: 2d54 7261 636b 3f0d 0a0d 0a60 6060 0d0a  -Track?....```..
-00000af0: 546f 2075 7365 2053 432d 5472 6163 6b2c  To use SC-Track,
-00000b00: 2070 6c65 6173 6520 666f 6c6c 6f77 2074   please follow t
-00000b10: 6865 2049 6e73 7461 6c6c 6174 696f 6e20  he Installation 
-00000b20: 7374 6570 7320 6669 7273 742e 2049 7420  steps first. It 
-00000b30: 646f 6573 206e 6f74 2072 6571 7569 7265  does not require
-00000b40: 2074 6f6f 206d 616e 7920 7365 7474 696e   too many settin
-00000b50: 6773 2064 7572 696e 6720 6974 7320 7573  gs during its us
-00000b60: 652e 2057 6865 6e20 796f 7520 6f6e 6c79  e. When you only
-00000b70: 2068 6176 6520 6120 7369 6e67 6c65 2d63   have a single-c
-00000b80: 6861 6e6e 656c 2073 6567 6d65 6e74 6174  hannel segmentat
-00000b90: 696f 6e20 7265 7375 6c74 2c20 7765 2072  ion result, we r
-00000ba0: 6571 7569 7265 2074 6861 7420 796f 7572  equire that your
-00000bb0: 2073 6567 6d65 6e74 6174 696f 6e20 7265   segmentation re
-00000bc0: 7375 6c74 206d 7573 7420 6265 2061 206d  sult must be a m
-00000bd0: 6173 6b20 6772 6179 7363 616c 6520 6669  ask grayscale fi
-00000be0: 6c65 2069 6e20 7468 6520 666f 726d 206f  le in the form o
-00000bf0: 6620 3244 2b74 2069 6e20 7469 6666 2066  f 2D+t in tiff f
-00000c00: 6f72 6d61 742e 2054 6865 2063 656c 6c73  ormat. The cells
-00000c10: 2069 6e20 6561 6368 206d 6173 6b20 6e65   in each mask ne
-00000c20: 6564 2074 6f20 6775 6172 616e 7465 6520  ed to guarantee 
-00000c30: 7468 6569 7220 7069 7865 6c20 7661 6c75  their pixel valu
-00000c40: 6573 2e20 6973 2075 6e69 7175 653b 206f  es. is unique; o
-00000c50: 7220 6120 4a53 4f4e 2063 6f6d 6d65 6e74  r a JSON comment
-00000c60: 2066 696c 652e 2054 6865 2073 7065 6369   file. The speci
-00000c70: 6669 6320 666f 726d 6174 2063 616e 2072  fic format can r
-00000c80: 6566 6572 2074 6f20 6f75 7220 6578 616d  efer to our exam
-00000c90: 706c 652e 0d0a 0d0a 5768 656e 2074 6865  ple.....When the
-00000ca0: 2073 6567 6d65 6e74 6174 696f 6e20 7265   segmentation re
-00000cb0: 7375 6c74 2069 7320 6120 6d61 736b 2c20  sult is a mask, 
-00000cc0: 706c 6561 7365 2072 756e 3a20 7363 7472  please run: sctr
-00000cd0: 6163 6b20 2d70 2069 6d61 6765 2e74 6966  ack -p image.tif
-00000ce0: 202d 6120 6d61 736b 2e74 6966 2e0d 0a57   -a mask.tif...W
-00000cf0: 6865 6e20 7468 6520 7365 676d 656e 7461  hen the segmenta
-00000d00: 7469 6f6e 2072 6573 756c 7420 6973 2061  tion result is a
-00000d10: 6e20 616e 6e6f 7461 7469 6f6e 206a 736f  n annotation jso
-00000d20: 6e20 6669 6c65 2c20 706c 6561 7365 2072  n file, please r
-00000d30: 756e 3a20 7363 7472 6163 6b20 2d70 2069  un: sctrack -p i
-00000d40: 6d61 6765 2e74 6966 202d 6120 616e 6e6f  mage.tif -a anno
-00000d50: 7461 7469 6f6e 2e6a 736f 6e2e 0d0a 5768  tation.json...Wh
-00000d60: 6572 6520 696d 6167 652e 7469 6620 6973  ere image.tif is
-00000d70: 2074 6865 206f 7269 6769 6e61 6c20 696d   the original im
-00000d80: 6167 652c 206d 6173 6b2e 7469 662c 2061  age, mask.tif, a
-00000d90: 6e64 2061 6e6e 6f74 6174 696f 6e2e 6a73  nd annotation.js
-00000da0: 6f6e 2061 7265 2061 6e6e 6f74 6174 696f  on are annotatio
-00000db0: 6e20 6669 6c65 732e 2054 6865 206f 7269  n files. The ori
-00000dc0: 6769 6e61 6c20 696d 6167 6520 6d61 7920  ginal image may 
-00000dd0: 6e6f 7420 6265 2070 726f 7669 6465 642c  not be provided,
-00000de0: 2062 7574 2069 6620 7468 6520 6f72 6967   but if the orig
-00000df0: 696e 616c 2069 6d61 6765 2069 7320 6e6f  inal image is no
-00000e00: 7420 7072 6f76 6964 6564 2c20 7468 6520  t provided, the 
-00000e10: 7669 7375 616c 697a 6174 696f 6e20 7265  visualization re
-00000e20: 7375 6c74 2063 616e 6e6f 7420 6265 206f  sult cannot be o
-00000e30: 7574 7075 742e 0d0a 6060 600d 0a0d 0a0d  utput...```.....
-00000e40: 0a0d 0a23 2323 2049 6e73 7461 6c6c 6174  ...### Installat
-00000e50: 696f 6e0d 0a0d 0a60 6060 0d0a 5265 7175  ion....```..Requ
-00000e60: 6972 656d 656e 743a 2050 7974 686f 6e20  irement: Python 
-00000e70: 3e3d 2033 2e37 0d0a 0d0a 5769 6e64 6f77  >= 3.7....Window
-00000e80: 733a 2070 6970 2069 736e 7461 6c6c 2053  s: pip isntall S
-00000e90: 432d 5472 6163 6b0d 0a4c 696e 7578 2f4d  C-Track..Linux/M
-00000ea0: 6163 6f73 3a20 7069 7033 2069 736e 7461  acos: pip3 isnta
-00000eb0: 6c6c 2053 432d 5472 6163 6b0d 0a0d 0a60  ll SC-Track....`
-00000ec0: 6060 0d0a 0d0a 2d20 2020 4e6f 7465 efbc  ``....-   Note..
-00000ed0: 9a20 4f6e 2060 5769 6e64 6f77 7360 2c20  . On `Windows`, 
-00000ee0: 7468 6520 7265 7175 6972 656d 656e 7420  the requirement 
-00000ef0: 7061 636b 6167 6520 6070 796c 6962 7469  package `pylibti
-00000f00: 6666 2060 6361 6e6e 6f74 2064 6972 6563  ff `cannot direc
-00000f10: 746c 7920 696e 7374 616c 6c20 6279 2070  tly install by p
-00000f20: 6970 2c20 706c 6561 7365 2069 6e73 7461  ip, please insta
-00000f30: 6c6c 2077 6974 6820 7468 6973 2063 6f6d  ll with this com
-00000f40: 6d61 6e64 3a0d 0a0d 0a20 2020 2060 636f  mand:....    `co
-00000f50: 6e64 6120 696e 7374 616c 6c20 6c69 6274  nda install libt
-00000f60: 6966 6660 0d0a 0d0a 2020 2020 6f72 2079  iff`....    or y
-00000f70: 6f75 2063 616e 2064 6f77 6e6c 6f61 6420  ou can download 
-00000f80: 7468 6520 7768 6565 6c20 7061 636b 6167  the wheel packag
-00000f90: 6520 6672 6f6d 205b 6865 7265 5d28 6874  e from [here](ht
-00000fa0: 7470 733a 2f2f 7777 772e 6c66 642e 7563  tps://www.lfd.uc
-00000fb0: 692e 6564 752f 7e67 6f68 6c6b 652f 7079  i.edu/~gohlke/py
-00000fc0: 7468 6f6e 6c69 6273 2f23 7079 6c69 6274  thonlibs/#pylibt
-00000fd0: 6966 6629 2c20 616e 6420 7468 656e 2075  iff), and then u
-00000fe0: 7369 6e67 2060 7069 7020 696e 7374 616c  sing `pip instal
-00000ff0: 6c20 7079 6c69 6274 6966 662e 7768 6c60  l pylibtiff.whl`
-00001000: 2074 6f20 696e 7374 616c 6c2e 0d0a 0d0a   to install.....
-00001010: 2020 2020 4f6e 2060 4c69 6e75 7860 206f      On `Linux` o
-00001020: 7220 604d 6163 6f73 602c 206a 7573 7420  r `Macos`, just 
-00001030: 7573 696e 6720 6070 6970 2069 6e73 7461  using `pip insta
-00001040: 6c6c 2070 796c 6962 7469 6666 6020 746f  ll pylibtiff` to
-00001050: 2069 6e73 7461 6c6c 2e0d 0a0d 0a0d 0a0d   install........
-00001060: 0a0d 0a0d 0a23 2323 2055 7361 6765 0d0a  .....### Usage..
-00001070: 0d0a 6060 6070 7974 686f 6e0d 0a57 6520  ..```python..We 
-00001080: 7072 6f76 6964 6520 6120 636f 6d6d 616e  provide a comman
-00001090: 6420 6c69 6e65 2074 6f6f 6c2c 2079 6f75  d line tool, you
-000010a0: 206f 6e6c 7920 6e65 6564 2074 6f20 7275   only need to ru
-000010b0: 6e20 7468 6520 7363 7472 6163 6b20 746f  n the sctrack to
-000010c0: 6f6c 206f 6e20 7468 6520 636f 6d6d 616e  ol on the comman
-000010d0: 6420 6c69 6e65 2e20 546f 2061 7574 6f6d  d line. To autom
-000010e0: 6174 6520 6261 7463 6820 7072 6f63 6573  ate batch proces
-000010f0: 7369 6e67 206f 6620 6120 6c61 7267 6520  sing of a large 
-00001100: 6e75 6d62 6572 206f 6620 6669 6c65 732c  number of files,
-00001110: 2070 6c65 6173 6520 7265 6665 7220 746f   please refer to
-00001120: 206f 7572 2073 6f75 7263 6520 636f 6465   our source code
-00001130: 2064 6f63 756d 656e 7461 7469 6f6e 2e0d   documentation..
-00001140: 0a49 7473 2062 6173 6963 2075 7361 6765  .Its basic usage
-00001150: 2069 733a 0d0a 2020 2020 0d0a 6672 6f6d   is:..    ..from
-00001160: 2053 4354 7261 636b 2069 6d70 6f72 7420   SCTrack import 
-00001170: 7374 7261 745f 7472 6163 6b0d 0a0d 0a69  strat_track....i
-00001180: 6d61 6765 203d 2027 7061 7468 2f74 6f2f  mage = 'path/to/
-00001190: 696d 6167 652e 7469 6627 0d0a 0d0a 2320  image.tif'....# 
-000011a0: 7573 696e 6720 6d61 736b 2061 6e6e 6f74  using mask annot
-000011b0: 6174 696f 6e0d 0a61 6e6e 6f74 6174 696f  ation..annotatio
-000011c0: 6e5f 6d61 736b 203d 2027 2f70 6174 682f  n_mask = '/path/
-000011d0: 746f 2f61 6e6e 6f74 6174 696f 6e2e 7469  to/annotation.ti
-000011e0: 6627 0d0a 7374 6172 745f 7472 6163 6b28  f'..start_track(
-000011f0: 6661 6e6e 6f74 6174 696f 6e3d 616e 6e6f  fannotation=anno
-00001200: 7461 7469 6f6e 5f6d 6173 6b2c 2066 696d  tation_mask, fim
-00001210: 6167 653d 696d 6167 6529 0d0a 0d0a 2320  age=image)....# 
-00001220: 7573 696e 6720 6a73 6f6e 2066 696c 6520  using json file 
-00001230: 616e 6e6f 7461 7469 6f6e 0d0a 616e 6e6f  annotation..anno
-00001240: 7461 7469 6f6e 5f6a 736f 6e20 3d20 272f  tation_json = '/
-00001250: 7061 7468 2f74 6f2f 616e 6e6f 7461 7469  path/to/annotati
-00001260: 6f6e 2e6a 736f 6e27 0d0a 7374 6172 745f  on.json'..start_
-00001270: 7472 6163 6b28 6661 6e6e 6f74 6174 696f  track(fannotatio
-00001280: 6e3d 616e 6e6f 7461 7469 6f6e 5f6a 736f  n=annotation_jso
-00001290: 6e2c 2066 696d 6167 653d 696d 6167 6529  n, fimage=image)
-000012a0: 0d0a 6060 600d 0a0d 0a                   ..```....
+00000150: 2323 203c 6469 7620 616c 6967 6e3d 2263  ## <div align="c
+00000160: 656e 7465 7222 2073 7479 6c65 3d22 7465  enter" style="te
+00000170: 7874 2d61 6c69 676e 3a20 6365 6e74 6572  xt-align: center
+00000180: 3b20 666f 6e74 2d73 697a 653a 2033 3270  ; font-size: 32p
+00000190: 783b 223e 203c 623e 3c61 2068 7265 663d  x;"> <b><a href=
+000001a0: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
+000001b0: 6f6d 2f66 726f 7a65 6e6c 6561 7665 732f  om/frozenleaves/
+000001c0: 5343 2d54 7261 636b 3e53 432d 5472 6163  SC-Track>SC-Trac
+000001d0: 6b20 3a20 2054 7261 636b 696e 6720 2066  k :  Tracking  f
+000001e0: 6f72 2020 5369 6e67 6c65 2020 4365 6c6c  or  Single  Cell
+000001f0: 3c2f 613e 3c2f 623e 3c2f 6469 763e 0d0a  </a></b></div>..
+00000200: 0d0a 3c64 6976 2061 6c69 676e 3d22 6365  ..<div align="ce
+00000210: 6e74 6572 223e 203c 696d 6720 7372 633d  nter"> <img src=
+00000220: 2264 6f63 732f 6963 6f6e 2f6c 6963 656e  "docs/icon/licen
+00000230: 7365 2e73 7667 2220 7769 6474 6820 3d20  se.svg" width = 
+00000240: 3232 3020 2f3e 203c 696d 6720 7372 633d  220 /> <img src=
+00000250: 2264 6f63 732f 6963 6f6e 2f77 6865 656c  "docs/icon/wheel
+00000260: 2e73 7667 2220 7769 6474 6820 3d20 3730  .svg" width = 70
+00000270: 202f 3e20 203c 696d 6720 7372 633d 2264   />  <img src="d
+00000280: 6f63 732f 6963 6f6e 2f64 6f63 732e 7376  ocs/icon/docs.sv
+00000290: 6722 2077 6964 7468 203d 2038 3020 2f3e  g" width = 80 />
+000002a0: 203c 696d 6720 7372 633d 2264 6f63 732f   <img src="docs/
+000002b0: 6963 6f6e 2f50 7974 686f 6e2d 7665 7273  icon/Python-vers
+000002c0: 696f 6e2e 7376 6722 2077 6964 7468 203d  ion.svg" width =
+000002d0: 2032 3030 202f 3e20 3c2f 6469 763e 200d   200 /> </div> .
+000002e0: 0a0d 0a23 2323 2057 6861 7427 7320 2053  ...### What's  S
+000002f0: 432d 5472 6163 6b3f 0d0a 0d0a 5343 2d54  C-Track?....SC-T
+00000300: 7261 636b 2069 7320 616e 2065 6666 6963  rack is an effic
+00000310: 6965 6e74 2061 6c67 6f72 6974 686d 2066  ient algorithm f
+00000320: 6f72 2064 796e 616d 6963 2074 7261 636b  or dynamic track
+00000330: 696e 6720 6f66 2073 696e 676c 6520 6365  ing of single ce
+00000340: 6c6c 7320 6f6e 2064 6966 6665 7265 6e74  lls on different
+00000350: 2074 696d 652d 6c61 7073 6520 6d69 6372   time-lapse micr
+00000360: 6f73 636f 7065 2069 6d61 6765 732e 200d  oscope images. .
+00000370: 0a49 7420 6361 6e20 7573 6520 7468 6520  .It can use the 
+00000380: 7365 676d 656e 7461 7469 6f6e 2072 6573  segmentation res
+00000390: 756c 7473 206f 6620 7661 7269 6f75 7320  ults of various 
+000003a0: 6d6f 6465 6c73 2074 6f20 6566 6669 6369  models to effici
+000003b0: 656e 746c 7920 7472 6163 6b20 7369 6e67  ently track sing
+000003c0: 6c65 2063 656c 6c73 2061 6e64 2072 6563  le cells and rec
+000003d0: 6f6e 7374 7275 6374 2063 656c 6c20 6c69  onstruct cell li
+000003e0: 6e65 732e 200d 0a49 7420 6361 6e20 7472  nes. ..It can tr
+000003f0: 6163 6b20 6d75 6c74 692d 6765 6e65 7261  ack multi-genera
+00000400: 7469 6f6e 616c 2063 656c 6c20 6469 7669  tional cell divi
+00000410: 7369 6f6e 2065 7665 6e74 7320 7769 7468  sion events with
+00000420: 6f75 7420 616e 7920 6164 6469 7469 6f6e  out any addition
+00000430: 616c 2069 6e66 6f72 6d61 7469 6f6e 2c20  al information, 
+00000440: 6f6e 6c79 2075 7369 6e67 2074 6865 206f  only using the o
+00000450: 7574 6c69 6e65 2069 6e66 6f72 6d61 7469  utline informati
+00000460: 6f6e 206f 6620 6365 6c6c 733b 200d 0a61  on of cells; ..a
+00000470: 6e64 2063 616e 2072 6564 7563 6520 7468  nd can reduce th
+00000480: 6520 6e6f 6973 6520 6f66 2074 6865 2073  e noise of the s
+00000490: 6567 6d65 6e74 6174 696f 6e2c 2073 6f20  egmentation, so 
+000004a0: 6173 2074 6f20 7573 6520 7468 6520 6e6f  as to use the no
+000004b0: 6973 6520 7365 676d 656e 7461 7469 6f6e  ise segmentation
+000004c0: 2072 6573 756c 7473 2074 6f20 6765 6e65   results to gene
+000004d0: 7261 7465 2061 6363 7572 6174 6520 6365  rate accurate ce
+000004e0: 6c6c 206c 696e 6561 6765 732e 200d 0a49  ll lineages. ..I
+000004f0: 7473 2063 6173 6361 6465 2d63 6163 6869  ts cascade-cachi
+00000500: 6e67 206d 6f64 656c 2063 616e 2065 6666  ng model can eff
+00000510: 6963 6965 6e74 6c79 2064 6561 6c20 7769  iciently deal wi
+00000520: 7468 2073 6567 6d65 6e74 6174 696f 6e20  th segmentation 
+00000530: 6c6f 7373 2c20 616e 6420 6974 7320 5450  loss, and its TP
+00000540: 5320 616c 676f 7269 7468 6d20 6361 6e20  S algorithm can 
+00000550: 7065 7266 6f72 6d20 6163 6375 7261 7465  perform accurate
+00000560: 2072 6563 6c61 7373 6966 6963 6174 696f   reclassificatio
+00000570: 6e20 0d0a 666f 7220 7573 6572 7320 7769  n ..for users wi
+00000580: 7468 2063 656c 6c20 636c 6173 7369 6669  th cell classifi
+00000590: 6361 7469 6f6e 206e 6565 6473 2028 7375  cation needs (su
+000005a0: 6368 2061 7320 636c 6173 7369 6669 6361  ch as classifica
+000005b0: 7469 6f6e 206f 6620 6469 6666 6572 656e  tion of differen
+000005c0: 7420 6365 6c6c 2063 7963 6c65 2070 6861  t cell cycle pha
+000005d0: 7365 7329 2e20 0d0a 5343 2d54 7261 636b  ses). ..SC-Track
+000005e0: 2061 6c6c 6f77 7320 7573 6572 7320 746f   allows users to
+000005f0: 2075 7365 2064 6966 6665 7265 6e74 2073   use different s
+00000600: 6567 6d65 6e74 6174 696f 6e20 7265 7375  egmentation resu
+00000610: 6c74 7320 6173 2069 6e70 7574 2c20 696e  lts as input, in
+00000620: 636c 7564 696e 6720 7468 6520 4a53 4f4e  cluding the JSON
+00000630: 2061 6e6e 6f74 6174 696f 6e20 6669 6c65   annotation file
+00000640: 2066 6f72 6d61 7420 7375 7070 6f72 7465   format supporte
+00000650: 6420 6279 2056 4747 2069 6d61 6765 2061  d by VGG image a
+00000660: 6e6e 6f74 6174 6f72 2c20 0d0a 616e 6420  nnotator, ..and 
+00000670: 7468 6520 636f 6d6d 6f6e 206d 6173 6b20  the common mask 
+00000680: 6772 6179 7363 616c 6520 696d 6167 6520  grayscale image 
+00000690: 666f 726d 6174 2e20 5468 6520 6578 706f  format. The expo
+000006a0: 7274 2072 6573 756c 7473 2069 6e63 6c75  rt results inclu
+000006b0: 6465 2074 7261 636b 2074 6162 6c65 2c20  de track table, 
+000006c0: 7669 7375 616c 697a 6564 206c 6162 656c  visualized label
+000006d0: 6564 2069 6d61 6765 2c20 0d0a 4a53 4f4e  ed image, ..JSON
+000006e0: 2066 696c 6520 636f 6e74 6169 6e69 6e67   file containing
+000006f0: 2074 7261 636b 696e 6720 696e 666f 726d   tracking inform
+00000700: 6174 696f 6e20 2877 6869 6368 2063 616e  ation (which can
+00000710: 2062 6520 696d 706f 7274 6564 2069 6e74   be imported int
+00000720: 6f20 5647 4720 696d 6167 6520 616e 6e6f  o VGG image anno
+00000730: 7461 746f 7220 666f 7220 7669 6577 696e  tator for viewin
+00000740: 6729 2c20 0d0a 616e 6420 6120 636f 6c6c  g), ..and a coll
+00000750: 6563 7469 6f6e 206f 6620 5472 6163 6b69  ection of Tracki
+00000760: 6e67 5472 6565 2073 7472 7563 7475 7265  ngTree structure
+00000770: 2074 7265 6520 6669 6c65 732e 2055 7365   tree files. Use
+00000780: 7273 2063 616e 2070 6572 666f 726d 206d  rs can perform m
+00000790: 6f72 6520 6465 7461 696c 6564 2064 6f77  ore detailed dow
+000007a0: 6e73 7472 6561 6d20 616e 616c 7973 6973  nstream analysis
+000007b0: 206f 6e20 7468 6520 7472 6163 6b20 7461   on the track ta
+000007c0: 626c 652c 200d 0a76 6965 7720 7468 6520  ble, ..view the 
+000007d0: 7472 6163 6b69 6e67 2072 6573 756c 7473  tracking results
+000007e0: 2074 6872 6f75 6768 2076 6973 7561 6c69   through visuali
+000007f0: 7a65 6420 7265 7375 6c74 732c 2061 6e64  zed results, and
+00000800: 206d 6f64 6966 7920 7468 6520 7472 6163   modify the trac
+00000810: 6b20 7461 626c 6520 6f72 2074 7261 636b  k table or track
+00000820: 206a 736f 6e20 6669 6c65 2074 6f20 6d61   json file to ma
+00000830: 6e75 616c 6c79 2063 6f72 7265 6374 2074  nually correct t
+00000840: 7261 636b 696e 6720 6572 726f 7273 2e20  racking errors. 
+00000850: 0d0a 5343 2d54 7261 636b 2069 7320 6e6f  ..SC-Track is no
+00000860: 7420 6f6e 6c79 2073 7569 7461 626c 6520  t only suitable 
+00000870: 666f 7220 736d 616c 6c20 7469 6d65 6c61  for small timela
+00000880: 7073 6520 616e 616c 7973 6973 2c20 6275  pse analysis, bu
+00000890: 7420 616c 736f 2073 7569 7461 626c 6520  t also suitable 
+000008a0: 666f 7220 6c6f 6e67 2074 696d 6520 616e  for long time an
+000008b0: 6420 6869 6768 2063 656c 6c20 6465 6e73  d high cell dens
+000008c0: 6974 7920 7469 6d65 6c61 7073 6520 616e  ity timelapse an
+000008d0: 616c 7973 6973 206f 6620 7468 6f75 7361  alysis of thousa
+000008e0: 6e64 7320 6f66 2066 7261 6d65 732e 0d0a  nds of frames...
+000008f0: 0d0a 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 0d0a  ..----------....
+00000900: 0d0a 2323 2320 5768 7920 7573 696e 6720  ..### Why using 
+00000910: 2053 432d 5472 6163 6b3f 0d0a 0d0a 2d20   SC-Track?....- 
+00000920: 2020 5468 6520 6375 7272 656e 7420 6d61    The current ma
+00000930: 696e 7374 7265 616d 206d 6574 686f 6473  instream methods
+00000940: 2066 6f72 2069 6d61 6765 2073 6567 6d65   for image segme
+00000950: 6e74 6174 696f 6e20 616c 6c20 7573 6520  ntation all use 
+00000960: 6465 6570 206c 6561 726e 696e 672c 2061  deep learning, a
+00000970: 6e64 2074 6865 206f 7574 7075 7420 7265  nd the output re
+00000980: 7375 6c74 7320 636f 6e74 6169 6e20 6e6f  sults contain no
+00000990: 6973 6573 206f 6620 7661 7279 696e 6720  ises of varying 
+000009a0: 696e 7465 6e73 6974 6965 732e 2053 432d  intensities. SC-
+000009b0: 5472 6163 6b20 6973 2063 7572 7265 6e74  Track is current
+000009c0: 6c79 2074 6865 206f 6e6c 7920 616c 676f  ly the only algo
+000009d0: 7269 7468 6d20 7468 6174 2063 616e 2075  rithm that can u
+000009e0: 7365 2074 6865 7365 206e 6f69 7365 2064  se these noise d
+000009f0: 6174 6120 666f 7220 6163 6375 7261 7465  ata for accurate
+00000a00: 2073 696e 676c 652d 6365 6c6c 2074 7261   single-cell tra
+00000a10: 636b 696e 6720 616e 6420 6c69 6e65 6167  cking and lineag
+00000a20: 6520 7265 636f 6e73 7472 7563 7469 6f6e  e reconstruction
+00000a30: 2e0d 0a2d 2053 432d 5472 6163 6b20 6973  ...- SC-Track is
+00000a40: 2063 6f6d 7061 7469 626c 6520 7769 7468   compatible with
+00000a50: 2074 6865 206f 7574 7075 7420 7265 7375   the output resu
+00000a60: 6c74 7320 6f66 206d 6f73 7420 6f66 2074  lts of most of t
+00000a70: 6865 2065 7869 7374 696e 6720 6d61 696e  he existing main
+00000a80: 7374 7265 616d 2073 6567 6d65 6e74 6174  stream segmentat
+00000a90: 696f 6e20 6d6f 6465 6c73 2c20 6173 2077  ion models, as w
+00000aa0: 656c 6c20 6173 206d 616e 7561 6c20 7365  ell as manual se
+00000ab0: 676d 656e 7461 7469 6f6e 2072 6573 756c  gmentation resul
+00000ac0: 7473 2c20 696e 636c 7564 696e 6720 4365  ts, including Ce
+00000ad0: 6c6c 706f 7365 2c20 4465 6570 4365 6c6c  llpose, DeepCell
+00000ae0: 2c20 5374 6172 6469 7374 2c20 6574 632e  , Stardist, etc.
+00000af0: 2055 7365 7273 2063 616e 2063 686f 6f73   Users can choos
+00000b00: 6520 6120 6d6f 7265 2061 6476 616e 6365  e a more advance
+00000b10: 6420 616e 6420 7375 6974 6162 6c65 2073  d and suitable s
+00000b20: 6567 6d65 6e74 6174 696f 6e20 6d6f 6465  egmentation mode
+00000b30: 6c20 6163 636f 7264 696e 6720 746f 2074  l according to t
+00000b40: 6865 2063 656c 6c20 7479 7065 2074 6f20  he cell type to 
+00000b50: 7370 6c69 742e 0d0a 2d20 5343 2d54 7261  split...- SC-Tra
+00000b60: 636b 2063 616e 2065 6666 6963 6965 6e74  ck can efficient
+00000b70: 6c79 2074 7261 636b 206d 756c 7469 706c  ly track multipl
+00000b80: 6520 7461 7267 6574 7320 6265 7477 6565  e targets betwee
+00000b90: 6e20 6672 616d 6573 2077 6974 686f 7574  n frames without
+00000ba0: 2072 656c 7969 6e67 206f 6e20 676c 6f62   relying on glob
+00000bb0: 616c 2069 6e66 6f72 6d61 7469 6f6e 2c20  al information, 
+00000bc0: 616e 6420 6361 6e20 6265 2075 7365 6420  and can be used 
+00000bd0: 666f 7220 7265 616c 2d74 696d 6520 7472  for real-time tr
+00000be0: 6163 6b69 6e67 2e0d 0a2d 2053 432d 5472  acking...- SC-Tr
+00000bf0: 6163 6b20 6973 2069 6d70 6c65 6d65 6e74  ack is implement
+00000c00: 6564 2069 6e20 5079 7468 6f6e 2c20 7768  ed in Python, wh
+00000c10: 6963 6820 6861 7320 7374 726f 6e67 2073  ich has strong s
+00000c20: 6361 6c61 6269 6c69 7479 2c20 636f 6e76  calability, conv
+00000c30: 656e 6965 6e74 2061 6e64 2071 7569 636b  enient and quick
+00000c40: 2069 6e73 7461 6c6c 6174 696f 6e2c 2061   installation, a
+00000c50: 6e64 206c 6f77 2064 6570 656e 6465 6e63  nd low dependenc
+00000c60: 792e 0d0a 0d0a 0d0a 0d0a 2d2d 2d2d 2d2d  y.........------
+00000c70: 2d0d 0a0d 0a23 2323 2048 6f77 2074 6f20  -....### How to 
+00000c80: 7573 6520 5343 2d54 7261 636b 3f0d 0a0d  use SC-Track?...
+00000c90: 0a60 6060 6d61 726b 646f 776e 0d0a 546f  .```markdown..To
+00000ca0: 2075 7365 2053 432d 5472 6163 6b2c 2070   use SC-Track, p
+00000cb0: 6c65 6173 6520 666f 6c6c 6f77 2074 6865  lease follow the
+00000cc0: 2049 6e73 7461 6c6c 6174 696f 6e20 7374   Installation st
+00000cd0: 6570 7320 6669 7273 742e 2049 7420 646f  eps first. It do
+00000ce0: 6573 206e 6f74 2072 6571 7569 7265 2074  es not require t
+00000cf0: 6f6f 206d 616e 7920 7365 7474 696e 6773  oo many settings
+00000d00: 2064 7572 696e 6720 6974 7320 7573 652e   during its use.
+00000d10: 2057 6865 6e20 796f 7520 6f6e 6c79 2068   When you only h
+00000d20: 6176 6520 6120 0d0a 0d0a 7369 6e67 6c65  ave a ....single
+00000d30: 2d63 6861 6e6e 656c 2073 6567 6d65 6e74  -channel segment
+00000d40: 6174 696f 6e20 7265 7375 6c74 2c20 7765  ation result, we
+00000d50: 2072 6571 7569 7265 2074 6861 7420 796f   require that yo
+00000d60: 7572 2073 6567 6d65 6e74 6174 696f 6e20  ur segmentation 
+00000d70: 7265 7375 6c74 206d 7573 7420 6265 2061  result must be a
+00000d80: 206d 6173 6b20 6772 6179 7363 616c 6520   mask grayscale 
+00000d90: 6669 6c65 2069 6e20 7468 6520 666f 726d  file in the form
+00000da0: 206f 6620 3244 2b74 2069 6e20 0d0a 0d0a   of 2D+t in ....
+00000db0: 7469 6666 2066 6f72 6d61 742e 2054 6865  tiff format. The
+00000dc0: 2063 656c 6c73 2069 6e20 6561 6368 206d   cells in each m
+00000dd0: 6173 6b20 6e65 6564 2074 6f20 6775 6172  ask need to guar
+00000de0: 616e 7465 6520 7468 6569 7220 7069 7865  antee their pixe
+00000df0: 6c20 7661 6c75 6573 2e20 6973 2075 6e69  l values. is uni
+00000e00: 7175 653b 206f 7220 6120 4a53 4f4e 2063  que; or a JSON c
+00000e10: 6f6d 6d65 6e74 2066 696c 652e 2054 6865  omment file. The
+00000e20: 2073 7065 6369 6669 6320 666f 726d 6174   specific format
+00000e30: 2063 616e 200d 0a0d 0a72 6566 6572 2074   can ....refer t
+00000e40: 6f20 6f75 7220 6578 616d 706c 652e 0d0a  o our example...
+00000e50: 0d0a 5768 656e 2074 6865 2073 6567 6d65  ..When the segme
+00000e60: 6e74 6174 696f 6e20 7265 7375 6c74 2069  ntation result i
+00000e70: 7320 6120 6d61 736b 2c20 706c 6561 7365  s a mask, please
+00000e80: 2072 756e 3a20 6073 6374 7261 636b 202d   run: `sctrack -
+00000e90: 7020 696d 6167 652e 7469 6620 2d61 206d  p image.tif -a m
+00000ea0: 6173 6b2e 7469 6660 2e0d 0a57 6865 6e20  ask.tif`...When 
+00000eb0: 7468 6520 7365 676d 656e 7461 7469 6f6e  the segmentation
+00000ec0: 2072 6573 756c 7420 6973 2061 6e20 616e   result is an an
+00000ed0: 6e6f 7461 7469 6f6e 206a 736f 6e20 6669  notation json fi
+00000ee0: 6c65 2c20 706c 6561 7365 2072 756e 3a20  le, please run: 
+00000ef0: 6073 6374 7261 636b 202d 7020 696d 6167  `sctrack -p imag
+00000f00: 652e 7469 6620 2d61 2061 6e6e 6f74 6174  e.tif -a annotat
+00000f10: 696f 6e2e 6a73 6f6e 602e 0d0a 5768 6572  ion.json`...Wher
+00000f20: 6520 696d 6167 652e 7469 6620 6973 2074  e image.tif is t
+00000f30: 6865 206f 7269 6769 6e61 6c20 696d 6167  he original imag
+00000f40: 652c 206d 6173 6b2e 7469 662c 2061 6e64  e, mask.tif, and
+00000f50: 2061 6e6e 6f74 6174 696f 6e2e 6a73 6f6e   annotation.json
+00000f60: 2061 7265 2061 6e6e 6f74 6174 696f 6e20   are annotation 
+00000f70: 6669 6c65 732e 2054 6865 206f 7269 6769  files. The origi
+00000f80: 6e61 6c20 696d 6167 6520 6d61 7920 6e6f  nal image may no
+00000f90: 7420 6265 2070 726f 7669 6465 642c 200d  t be provided, .
+00000fa0: 0a62 7574 2069 6620 7468 6520 6f72 6967  .but if the orig
+00000fb0: 696e 616c 2069 6d61 6765 2069 7320 6e6f  inal image is no
+00000fc0: 7420 7072 6f76 6964 6564 2c20 7468 6520  t provided, the 
+00000fd0: 7669 7375 616c 697a 6174 696f 6e20 7265  visualization re
+00000fe0: 7375 6c74 2063 616e 6e6f 7420 6265 206f  sult cannot be o
+00000ff0: 7574 7075 742e 0d0a 6060 600d 0a0d 0a0d  utput...```.....
+00001000: 0a0d 0a2d 2d2d 2d2d 2d2d 2d2d 2d0d 0a0d  ...----------...
+00001010: 0a23 2323 2049 6e73 7461 6c6c 6174 696f  .### Installatio
+00001020: 6e0d 0a0d 0a60 6060 0d0a 5265 7175 6972  n....```..Requir
+00001030: 656d 656e 743a 2050 7974 686f 6e20 3e3d  ement: Python >=
+00001040: 2033 2e37 0d0a 0d0a 5769 6e64 6f77 733a   3.7....Windows:
+00001050: 2070 6970 2069 736e 7461 6c6c 2053 432d   pip isntall SC-
+00001060: 5472 6163 6b0d 0a4c 696e 7578 2f4d 6163  Track..Linux/Mac
+00001070: 6f73 3a20 7069 7033 2069 736e 7461 6c6c  os: pip3 isntall
+00001080: 2053 432d 5472 6163 6b0d 0a60 6060 0d0a   SC-Track..```..
+00001090: 0d0a 2d20 2020 4e6f 7465 efbc 9a20 4f6e  ..-   Note... On
+000010a0: 2060 5769 6e64 6f77 7360 2c20 7468 6520   `Windows`, the 
+000010b0: 7265 7175 6972 656d 656e 7420 7061 636b  requirement pack
+000010c0: 6167 6520 6070 796c 6962 7469 6666 2060  age `pylibtiff `
+000010d0: 6361 6e6e 6f74 2064 6972 6563 746c 7920  cannot directly 
+000010e0: 696e 7374 616c 6c20 6279 2070 6970 2c20  install by pip, 
+000010f0: 706c 6561 7365 2069 6e73 7461 6c6c 2077  please install w
+00001100: 6974 6820 7468 6973 2063 6f6d 6d61 6e64  ith this command
+00001110: 3a0d 0a0d 0a20 2020 2060 636f 6e64 6120  :....    `conda 
+00001120: 696e 7374 616c 6c20 6c69 6274 6966 6660  install libtiff`
+00001130: 0d0a 0d0a 2020 2020 6f72 2079 6f75 2063  ....    or you c
+00001140: 616e 2064 6f77 6e6c 6f61 6420 7468 6520  an download the 
+00001150: 7768 6565 6c20 7061 636b 6167 6520 6672  wheel package fr
+00001160: 6f6d 205b 6865 7265 5d28 6874 7470 733a  om [here](https:
+00001170: 2f2f 7777 772e 6c66 642e 7563 692e 6564  //www.lfd.uci.ed
+00001180: 752f 7e67 6f68 6c6b 652f 7079 7468 6f6e  u/~gohlke/python
+00001190: 6c69 6273 2f23 7079 6c69 6274 6966 6629  libs/#pylibtiff)
+000011a0: 2c20 616e 6420 7468 656e 2075 7369 6e67  , and then using
+000011b0: 2060 7069 7020 696e 7374 616c 6c20 7079   `pip install py
+000011c0: 6c69 6274 6966 662e 7768 6c60 2074 6f20  libtiff.whl` to 
+000011d0: 696e 7374 616c 6c2e 0d0a 0d0a 2020 2020  install.....    
+000011e0: 4f6e 2060 4c69 6e75 7860 206f 7220 604d  On `Linux` or `M
+000011f0: 6163 6f73 602c 206a 7573 7420 7573 696e  acos`, just usin
+00001200: 6720 6070 6970 2069 6e73 7461 6c6c 2070  g `pip install p
+00001210: 796c 6962 7469 6666 6020 746f 2069 6e73  ylibtiff` to ins
+00001220: 7461 6c6c 2e0d 0a0d 0a0d 0a0d 0a2d 2d2d  tall.........---
+00001230: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001240: 2d2d 2d2d 0d0a 0d0a 2323 2320 5573 6167  ----....### Usag
+00001250: 650d 0a0d 0a60 6060 7079 7468 6f6e 0d0a  e....```python..
+00001260: 5765 2070 726f 7669 6465 2061 2063 6f6d  We provide a com
+00001270: 6d61 6e64 206c 696e 6520 746f 6f6c 2c20  mand line tool, 
+00001280: 796f 7520 6f6e 6c79 206e 6565 6420 746f  you only need to
+00001290: 2072 756e 2074 6865 2073 6374 7261 636b   run the sctrack
+000012a0: 2074 6f6f 6c20 6f6e 2074 6865 2063 6f6d   tool on the com
+000012b0: 6d61 6e64 206c 696e 652e 2054 6f20 6175  mand line. To au
+000012c0: 746f 6d61 7465 200d 0a62 6174 6368 2070  tomate ..batch p
+000012d0: 726f 6365 7373 696e 6720 6f66 2061 206c  rocessing of a l
+000012e0: 6172 6765 206e 756d 6265 7220 6f66 2066  arge number of f
+000012f0: 696c 6573 2c20 706c 6561 7365 2072 6566  iles, please ref
+00001300: 6572 2074 6f20 6f75 7220 736f 7572 6365  er to our source
+00001310: 2063 6f64 6520 646f 6375 6d65 6e74 6174   code documentat
+00001320: 696f 6e2e 0d0a 4974 7320 6261 7369 6320  ion...Its basic 
+00001330: 7573 6167 6520 6973 3a0d 0a20 2020 200d  usage is:..    .
+00001340: 0a66 726f 6d20 5343 5472 6163 6b20 696d  .from SCTrack im
+00001350: 706f 7274 2073 7472 6174 5f74 7261 636b  port strat_track
+00001360: 0d0a 0d0a 696d 6167 6520 3d20 2770 6174  ....image = 'pat
+00001370: 682f 746f 2f69 6d61 6765 2e74 6966 270d  h/to/image.tif'.
+00001380: 0a0d 0a23 2075 7369 6e67 206d 6173 6b20  ...# using mask 
+00001390: 616e 6e6f 7461 7469 6f6e 0d0a 616e 6e6f  annotation..anno
+000013a0: 7461 7469 6f6e 5f6d 6173 6b20 3d20 272f  tation_mask = '/
+000013b0: 7061 7468 2f74 6f2f 616e 6e6f 7461 7469  path/to/annotati
+000013c0: 6f6e 2e74 6966 270d 0a73 7461 7274 5f74  on.tif'..start_t
+000013d0: 7261 636b 2866 616e 6e6f 7461 7469 6f6e  rack(fannotation
+000013e0: 3d61 6e6e 6f74 6174 696f 6e5f 6d61 736b  =annotation_mask
+000013f0: 2c20 6669 6d61 6765 3d69 6d61 6765 290d  , fimage=image).
+00001400: 0a0d 0a23 2075 7369 6e67 206a 736f 6e20  ...# using json 
+00001410: 6669 6c65 2061 6e6e 6f74 6174 696f 6e0d  file annotation.
+00001420: 0a61 6e6e 6f74 6174 696f 6e5f 6a73 6f6e  .annotation_json
+00001430: 203d 2027 2f70 6174 682f 746f 2f61 6e6e   = '/path/to/ann
+00001440: 6f74 6174 696f 6e2e 6a73 6f6e 270d 0a73  otation.json'..s
+00001450: 7461 7274 5f74 7261 636b 2866 616e 6e6f  tart_track(fanno
+00001460: 7461 7469 6f6e 3d61 6e6e 6f74 6174 696f  tation=annotatio
+00001470: 6e5f 6a73 6f6e 2c20 6669 6d61 6765 3d69  n_json, fimage=i
+00001480: 6d61 6765 290d 0a60 6060 0d0a 0d0a 0d0a  mage)..```......
+00001490: 0d0a 2d2d 2d2d 2d2d 0d0a 0d0a 2323 2320  ..------....### 
+000014a0: 4150 4920 2044 6f63 756d 656e 7461 7469  API  Documentati
+000014b0: 6f6e 0d0a 0d0a 466f 7220 6d6f 7265 2069  on....For more i
+000014c0: 6e66 6f72 6d61 7469 6f6e 2c20 706c 6561  nformation, plea
+000014d0: 7365 2073 6565 2074 6865 205b 7265 6665  se see the [refe
+000014e0: 7265 6e63 6520 646f 6375 6d65 6e74 735d  rence documents]
+000014f0: 2868 7474 7073 3a2f 2f73 632d 7472 6163  (https://sc-trac
+00001500: 6b2e 7265 6164 7468 6564 6f63 732e 696f  k.readthedocs.io
+00001510: 2f65 6e2f 6c61 7465 7374 2f29 2e0d 0a0d  /en/latest/)....
+00001520: 0a0d 0a0d 0a                             .....
```

### Comparing `SC-Track-0.0.4/SCTrack/base.py` & `SC-Track-0.0.5/SCTrack/base.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     Matched = 0
     Unmatched = 1
     LossMatch = 2
 
 
 class TreeStatus(object):
     """
-    Record the state of the tracked cells, including cell phase status, division status, and matching status
+    Record the state of the tracked cells, including cell cell_type status, division status, and matching status
     Phase: whether Mitosis has entered, and which frame has entered Mitosis
     Division: whether there is Mitosis
     Matching situation: Is there any loss of matching in this cell
     """
 
     # TreeStatus all Status properties
     __status_types = ['enter_mitosis', 'enter_mitosis_frame', 'division_event_happen',
@@ -59,15 +59,15 @@
 
     def __new__(cls, *args, **kwargs):
         key = str(args) + str(kwargs)
         if key not in cls._instances:
             cls._instances[key] = super().__new__(cls)
             cls._instances[key].__tracking_tree = None
             cls._instances[key].__init_flag = False
-            cls._instances[key].enter_mitosis_threshold = 50
+            cls._instances[key].enter_mitosis_threshold = config.ENTER_DIVISION_THRESHOLD
 
             # The cell division window stage, with an initial value of 20, will exit division matching when no cell
             # division is matched or cell division is completed during this window period. After entering the split
             # window period, this value will decrease every frame forward.
             cls._instances[key].division_windows_len = 20
 
             # Starting from the completion of splitting and exiting mitosis, counting, no further entry into mitosis
@@ -83,15 +83,15 @@
             self.__enter_mitosis_frame: int | None = None
             self.__division_event_happen: bool = False  # True indicates that the cell has at least one M    itosis
             self.__division_count: int = 0
             self.__exit_mitosis: bool = False
             self.__exit_mitosis_frame: int | None = None
             self.__match_status = MatchStatus.Unmatched
 
-            # This value records the number of predicted M phase. If > 3, it is considered to have entered M period,
+            # This value records the number of predicted M cell_type. If > 3, it is considered to have entered M period,
             # and at this point, enter needs to be called externally_ Mitosis()
             self.__predict_M_count = 0
             self.__init_flag = True
 
     @property
     def status(self):
         return dict(zip(TreeStatus.__status_types,
@@ -170,15 +170,15 @@
             self.__exit_mitosis_time += 1
 
     @property
     def is_mitosis_enter(self):
         return self.__enter_mitosis
 
     @property
-    def exist_mitosis_time(self):
+    def exit_mitosis_time(self):
         return self.__exit_mitosis_time
 
     def __str__(self):
         return str(self.status)
 
     def __repr__(self):
         return self.__str__()
@@ -472,20 +472,20 @@
             cls._instances[key].mitosis_start_flag = False
             cls._instances[key].__region = None
             cls._instances[key].__status = None
             cls._instances[key].__is_accurate_matched = False
             cls._instances[key].__match_status = False  # 匹配状态，如果参与匹配则设置为匹配状态，从未匹配则设置为False
         return cls._instances[key]
 
-    def __init__(self, position=None, mcy=None, dic=None, phase=None, frame_index=None, flag=None):
+    def __init__(self, position=None, mcy=None, dic=None, cell_type=None, frame_index=None, flag=None):
         # if  Cell.init_flag is False:
         self.position = position  # [(x1, x2 ... xn), (y1, y2 ... yn)]
         self.mcy = mcy
         self.dic = dic
-        self.phase = phase
+        self.cell_type = cell_type
         self.__id = None
         self.frame = frame_index
         self.__parent = None  # If a cell divides, record the __id of the cell's parent
         self.__move_speed = Vector(0, 0)
         self.polygon = Polygon([xy for xy in zip(*self.position)])
 
         if flag is None:
@@ -544,26 +544,23 @@
         """
         x_coords = vertex_coordinates[0]
         y_coords = vertex_coordinates[1]
         n = len(x_coords)
         area = 0.0
         centroid_x = 0.0
         centroid_y = 0.0
-
         for i in range(n):
             j = (i + 1) % n
             cross_product = x_coords[i] * y_coords[j] - x_coords[j] * y_coords[i]
             area += cross_product
             centroid_x += (x_coords[i] + x_coords[j]) * cross_product
             centroid_y += (y_coords[i] + y_coords[j]) * cross_product
-
         area /= 2.0
         centroid_x /= 6.0 * area
         centroid_y /= 6.0 * area
-
         return centroid_x, centroid_y
 
     @property
     @lru_cache(maxsize=None)
     def center(self):
         """
         :return: cell physical center
@@ -681,15 +678,15 @@
         """
         :param speed: move speed， Vector object instance
         :param time: move time，frame
         :return: New Cell instance after moving
         """
         new_position = [tuple([i + speed.x * time for i in self.position[0]]),
                         tuple([j + speed.y * time for j in self.position[1]])]
-        new_cell = Cell(position=new_position, mcy=self.mcy, dic=self.dic, phase=self.phase, frame_index=self.frame)
+        new_cell = Cell(position=new_position, mcy=self.mcy, dic=self.dic, cell_type=self.cell_type, frame_index=self.frame)
         new_cell.set_track_id(self.__track_id, 0)
         return new_cell
 
     def set_feature(self, feature):
         """set Feature object for cell"""
         self.__feature = feature
         self.__feature_flag = True
@@ -783,15 +780,15 @@
         return _background
 
     def __contains__(self, item):
         return True if self.available_range.isIntersect(Rectangle(*item.bbox)) else False
 
     def __str__(self):
         if self.position:
-            return f" Cell at ({self.center[0]: .2f},{self.center[1]: .2f}), frame {self.frame}, {self.phase}, branch {self.__branch_id}"
+            return f" Cell at ({self.center[0]: .2f},{self.center[1]: .2f}), frame {self.frame}, {self.cell_type}, branch {self.__branch_id}"
         else:
             return "Object Cell"
 
     def __repr__(self):
         return self.__str__()
 
     def __lt__(self, other):
```

### Comparing `SC-Track-0.0.4/SCTrack/feature.py` & `SC-Track-0.0.5/SCTrack/feature.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 import math
 from typing import Tuple, List
 import cv2
 import json
 
 import matplotlib.pyplot as plt
 import numpy as np
+import shapely.errors
 from tifffile import tifffile
 
 from SCTrack import config
 from SCTrack.base import Cell, Vector
 
 
 class Mask(object):
@@ -49,24 +50,24 @@
      - bbox_area: bounding box area
      - shape: sequence of cell outline coordinates
      - center: cell center coordinates
      - vector: the vector of the cell relative to the origin
      - bbox: the bounding box coordinates of the cell [y_min, y_max, x_min, x_max]
      - dic_intensity: the dic gray value intensity of the mask area
      - mcy_intensity: mcy gray value intensity of the mask area
-     - phase forecast period
+     - cell_type forecast period
 
 
     """
 
-    def __init__(self, center, bbox, area=None, shape=None, phase=None,
+    def __init__(self, center, bbox, area=None, shape=None, cell_type=None,
                  dic_intensity=None, dic_variance=None, mcy_intensity=None, mcy_variance=None, frame=None):
         self.center = center
         self.bbox = bbox
-        self.phase = phase
+        self.cell_type = cell_type
         self.mcy_intensity = mcy_intensity
         self.mcy_variance = mcy_variance
         self.dic_intensity = dic_intensity
         self.dic_variance = dic_variance
         self.shape = shape
         self.area = area
         self.vector = Vector(*center)
@@ -120,15 +121,15 @@
         for j in range(len(coord[0])):
             x = int(coord[0][j])
             y = int(coord[1][j])
             points.append((x, y))
         contours = np.array(points)
         return contours
 
-    def coordinate2mask(self, coords: np.ndarray | list | tuple, shape, value: int = 255) -> List[np.ndarray]:
+    def coordinate2mask(self, coords: np.ndarray | list | tuple, shape, value: int = 255) -> List[Mask]:
         """
         Draw the mask according to the contour coordinates. If you only pass in a set of contour coordinate values,
         be sure to put them in the list and pass in the function.
         For example, coord = ([x1 x2 ... xn], [y1 y2 ... yn]), please call it according to coordinate2mask([coord])
         """
         results = []
         for coord in coords:
@@ -197,44 +198,49 @@
             all_x.append(x)
             all_y.append(y)
         return all_x, all_y
 
     @lru_cache(maxsize=None)
     def get_cell_list(self):
         """
-        Get all cells in a single frame image
+        Get all cells in each single frame image
         """
         cell_list = []
         for region in self.annotation:
-            try:
+            if region['shape_attributes'].get('name') == 'ellipse':
+                rx = region['shape_attributes'].get('rx')
+                ry = region['shape_attributes'].get('ry')
+                cx = region['shape_attributes'].get('cx')
+                cy = region['shape_attributes'].get('cy')
+                theta = region['shape_attributes'].get('theta')
+                phase = region['region_attributes'].get('phase')
+                cell_type = region['region_attributes'].get('cell_type')
+                cell_type = cell_type if cell_type else phase
+                all_x, all_y = self.ellipse_points((cx, cy), rx, ry, num_points=32, theta=theta)
+            elif region['shape_attributes'].get('name') == 'polygon':
                 all_x = region['shape_attributes']['all_points_x']
                 all_y = region['shape_attributes']['all_points_y']
                 all_x = [0 if i < 0 else i for i in all_x]
                 all_y = [0 if j < 0 else j for j in all_y]
                 phase = region['region_attributes'].get('phase')
-                # phase = None
-                cell = Cell(position=(all_x, all_y), phase=phase, frame_index=self.frame_index)
+                cell_type = region['region_attributes'].get('cell_type')
+                cell_type = cell_type if cell_type else phase
+                # cell_type = None
+            else:
+                continue
+            try:
+                cell = Cell(position=(all_x, all_y), cell_type=cell_type, frame_index=self.frame_index)
                 cell.set_region(region)
+                _ = cell.center
+                _ = cell.polygon
                 cell_list.append(cell)
-            except KeyError:
-                # print(region)
-                if region['shape_attributes'].get('name') == 'ellipse':
-                    rx = region['shape_attributes'].get('rx')
-                    ry = region['shape_attributes'].get('ry')
-                    cx = region['shape_attributes'].get('cx')
-                    cy = region['shape_attributes'].get('cy')
-                    theta = region['shape_attributes'].get('theta')
-                    phase = region['region_attributes'].get('phase')
-                    # phase = None
-                    all_x, all_y = self.ellipse_points((cx, cy), rx, ry, num_points=32, theta=theta)
-                    cell = Cell(position=(all_x, all_y), phase=phase, frame_index=self.frame_index)
-                    cell.set_region(region)
-                    cell_list.append(cell)
-                else:
-                    print(region)
+            except ZeroDivisionError:
+                continue
+            except ValueError as e:
+                continue
         return cell_list
 
     def get_cell_image(self, cell: Cell):
         """
         Get dic and mcy images of cells
         """
         if config.USING_IMAGE_FOR_TRACKING:
```

### Comparing `SC-Track-0.0.4/SCTrack/generate_tracking_stack.py` & `SC-Track-0.0.5/SCTrack/generate_tracking_stack.py`

 * *Files identical despite different names*

### Comparing `SC-Track-0.0.4/SCTrack/prepare.py` & `SC-Track-0.0.5/SCTrack/prepare.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,23 +24,23 @@
 
     def get_regions_by_frame(self, frame_name):
         return self.__data[frame_name]['regions']
 
     def get_region_attr(self, regions):
         """
         regions: extract from json files, one frame data, it cna be get from function [get_regions_by_frame()]
-        Returns: all cells bounding box and phase list,
-        like [((x_min, x_max, y_min, y_max), phase), ..., ((x_min, x_max, y_min, y_max), phase)]
+        Returns: all cells bounding box and cell_type list,
+        like [((x_min, x_max, y_min, y_max), cell_type), ..., ((x_min, x_max, y_min, y_max), cell_type)]
 
         """
         attrs = []
         for i in regions:
             all_x = i['shape_attributes']['all_points_x']
             all_y = i['shape_attributes']['all_points_y']
-            phase = i['region_attributes']['phase']
+            phase = i['region_attributes']['cell_type']
             x_min = int(np.min(all_x))
             x_max = math.ceil(np.max(all_x))
             y_min = int(np.min(all_y))
             y_max = math.ceil(np.max(all_y))
             attrs.append([(x_min, x_max, y_min, y_max), phase])
         return attrs
```

### Comparing `SC-Track-0.0.4/SCTrack/reclassification.py` & `SC-Track-0.0.5/SCTrack/reclassification.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,26 @@
 import logging
 import os.path
-import sys
+from collections import Counter
 from copy import deepcopy
 from typing import List
 import json
-import random
-import pickle
+
+import cv2
+import matplotlib.pyplot as plt
+import numpy as np
 import pandas as pd
+import tifffile
+from imagesize import imagesize
+
 from SCTrack.base import Cell
 from SCTrack.tracker import Tracker, CellNode, TrackingTree
 from SCTrack.config import RAW_INPUT_IMAGE_SIZE
+from SCTrack.config import N_CLASS, CLASS_NAME
+from SCTrack import config
 
 
 class TreeParser(object):
     """parse TrackingTree"""
 
     def __init__(self, track_tree: TrackingTree):
         self.tree = track_tree
@@ -21,14 +28,15 @@
         self.lineage_dict = {}
         # {cells: [children_list], branch_id: ''， 'G1_start': '', 'S_start': '', 'G2_start': '', 'M1_start': '', 'M2_start': ''}
 
         self.root_parent_list = [self.tree.nodes.get(self.tree.root)]
         self.parse_root_flag = False
         self.parse_mitosis_flag = {}
         self.parse_s_flag = {}
+        self.smooth_flag = {}
 
         self.__division_count = 0
 
     def record_cell_division_count(self):
         self.__division_count += 1
         return self.__division_count
 
@@ -54,23 +62,23 @@
             while loop_queue:
                 current = loop_queue.pop(0)
                 ch = self.get_child(current)
                 for next_node in ch:
                     loop_queue.append(next_node)
                 if len(ch) > 1:
                     self.record_cell_division_count()
-                    if current not in self.lineage_dict:
-                        for child_cell in ch:
-                            self.lineage_dict[child_cell] = {'cells': [child_cell],
-                                                             'branch_id': child_cell.cell.branch_id,
-                                                             'branch_start': child_cell.cell.frame, 'parent': current}
-                            if child_cell not in self.root_parent_list:
-                                branch_id += 1
-                                child_cell.cell.set_cell_id(str(self.tree.track_id) + '_' + str(branch_id))
-                                self.root_parent_list.append(child_cell)
+                    # if current not in self.lineage_dict or current in self.lineage_dict:  # not useful branch
+                    for child_cell in ch:
+                        self.lineage_dict[child_cell] = {'cells': [child_cell],
+                                                         'branch_id': child_cell.cell.branch_id,
+                                                         'branch_start': child_cell.cell.frame, 'parent': current}
+                        if child_cell not in self.root_parent_list:
+                            branch_id += 1
+                            child_cell.cell.set_cell_id(str(self.tree.track_id) + '_' + str(branch_id))
+                            self.root_parent_list.append(child_cell)
         self.parse_root_flag = True
 
     def parse_lineage(self, root_node):
         """Get the cell node sequence contained in each branch"""
         loop_queue = [root_node]
         last_node = None
         while loop_queue:
@@ -109,64 +117,64 @@
 
     @staticmethod
     def check_mitosis_start(start_index, lineage_cell, area_size_t=0.9, mitosis_gap=20, m_predict_threshold=5):
         """
         Check the entry of the M period, if the area meets the conditions, check the next frame, if the area of the next
         frame is too small, it is not considered to have entered, and it is judged as a segmentation misjudgment.
         If the check is passed, check the next 6 frames. If the number of M phases is predicted to be greater than or
-        equal to the threshold, it is judged to enter the M phase to pass, otherwise, the judgment fails.
+        equal to the threshold, it is judged to enter the M cell_type to pass, otherwise, the judgment fails.
         If the interval from the last entry to M is too short, it is also considered a misjudgment
         """
         predict_enter_cell = lineage_cell[start_index]
         next_cell = lineage_cell[start_index + 1]
-        if lineage_cell[0].cell.phase == 'M' and start_index < mitosis_gap:
+        if lineage_cell[0].cell.cell_type == 'M' and start_index < mitosis_gap:
             return False
         elif next_cell.cell.area / predict_enter_cell.cell.area < area_size_t:
             return False
         else:
             predict_m_count = 0
             if len(lineage_cell) - start_index < 5:
                 return True
             for i in range(min(8, len(lineage_cell) - start_index)):
-                if lineage_cell[start_index + i].cell.phase == 'M':
+                if lineage_cell[start_index + i].cell.cell_type == 'M':
                     predict_m_count += 1
             if predict_m_count >= m_predict_threshold:
                 return True
             else:
                 return False
 
     @staticmethod
-    def check_s_start(start_index, linage_cell, threshold=6):
+    def check_ctype_start(type_name, start_index, linage_cell, threshold=config.PROB_THRESHOLD * config.SMOOTH_WINDOW_LEN):
         """
-        Check the entry of S phase, if the cell is predicted to be in S phase, check 10 frames later at random,
+        Check the entry of cell_type, if the cell is predicted to be in indicate cell_type, check 10 frames later,
         If the number of remaining frames is less than 10 frames, check all the remaining frames.
-        If the cumulative predicted S period is greater than the threshold,
+        If the cumulative predicted indicate cell type is greater than the threshold,
         If the judgment succeeds, otherwise, the judgment fails
         """
-        s_count = 0
-        if linage_cell[start_index].cell.phase == 'S':
-            for i in range(min(10, len(linage_cell) - start_index)):
-                if linage_cell[start_index + i].cell.phase == 'S':
-                    s_count += 1
-        if s_count >= threshold:
+        count = 0
+        if linage_cell[start_index].cell.cell_type == type_name:
+            for i in range(min(config.SMOOTH_WINDOW_LEN, len(linage_cell) - start_index)):
+                if linage_cell[start_index + i].cell.cell_type == type_name:
+                    count += 1
+        if count >= threshold:
             return True
         return False
 
     @staticmethod
-    def check_s_exit(end_index, linage_cell, threshold=6):
+    def check_ctype_exit(type_name, end_index, linage_cell, threshold=config.PROB_THRESHOLD * config.SMOOTH_WINDOW_LEN):
         """
-        To judge the exit of S phase, the judgment principle is the same as entering S phase,
-        if the cells start to exit S phase, check later
+        To judge the exit of cell_type, the judgment principle is the same as entering  cell_type,
+        if the cells start to exit cell_type, check later
         """
-        non_s_count = 0
-        if linage_cell[end_index].cell.phase != 'S':
-            for i in range(min(10, len(linage_cell) - end_index)):
-                if linage_cell[end_index + i].cell.phase != 'S':
-                    non_s_count += 1
-            if non_s_count >= threshold:
+        non_type_count = 0
+        if linage_cell[end_index].cell.cell_type != type_name:
+            for i in range(min(config.SMOOTH_WINDOW_LEN, len(linage_cell) - end_index)):
+                if linage_cell[end_index + i].cell.cell_type != type_name:
+                    non_type_count += 1
+            if non_type_count >= threshold:
                 return True
             return False
 
     def parse_mitosis(self, lineage: dict, root: CellNode, lineage_index=None):
         """
         Parse entry and exit of mitosis
         """
@@ -174,71 +182,71 @@
         cell_node_line = lineage.get('cells')
         mitosis_start_index = None
         exist_m_frame = 0
         for i in range(len(cell_node_line) - 1):
             before_cell_node = cell_node_line[i]
             current_cell_node = cell_node_line[i + 1]
             # print(f'{current_cell_node.cell.area / before_cell_node.cell.area:.2f}')
-            if before_cell_node.cell.phase == 'M':
+            if before_cell_node.cell.cell_type == 'M':
                 exist_m_frame += 1
             if current_cell_node.cell.area / before_cell_node.cell.area >= area_size_t:
-                if self.check_mitosis_start(i, cell_node_line):
+                if self.check_mitosis_start(i, cell_node_line, m_predict_threshold=config.PROB_THRESHOLD * config.SMOOTH_WINDOW_LEN):
                     mitosis_start_index = i + 1
                     break
-            elif before_cell_node.cell.phase == 'M' and current_cell_node.cell.area / before_cell_node.cell.area < area_size_t:
-                if self.check_mitosis_start(i, cell_node_line, m_predict_threshold=5):
+            elif before_cell_node.cell.cell_type == 'M' and current_cell_node.cell.area / before_cell_node.cell.area < area_size_t:
+                if self.check_mitosis_start(i, cell_node_line, m_predict_threshold=config.PROB_THRESHOLD * config.SMOOTH_WINDOW_LEN):
                     mitosis_start_index = i
                     break
         if mitosis_start_index is None:
             if len(cell_node_line) < 5:
                 if exist_m_frame >= 3:
                     for cell_node in cell_node_line:
-                        cell_node.cell.phase = 'M'
+                        cell_node.cell.cell_type = 'M'
                     lineage['m2_start'] = 0
             else:
                 if lineage_index != 0:
                     for cell_node in cell_node_line[: 3]:
-                        cell_node.cell.phase = 'M'
+                        cell_node.cell.cell_type = 'M'
                     lineage['m1_start'] = 0
         else:
             for m_index in range(mitosis_start_index, len(cell_node_line)):
-                cell_node_line[m_index].cell.phase = 'M'
+                cell_node_line[m_index].cell.cell_type = 'M'
             lineage['m2_start'] = mitosis_start_index
         self.parse_mitosis_flag[root] = True
 
     def parse_s(self, lineage: dict, root: CellNode, lineage_index=None):
-        """To judge the entry of S phase"""
+        """To judge the entry of S cell_type"""
         cell_node_line = lineage.get('cells')
         s_start_index = None
         s_exit_index = None
         if not self.parse_mitosis_flag[root]:
             self.parse_mitosis(lineage, root, lineage_index=lineage_index)
         if lineage.get('m1_start') is not None:
             check_start = lineage.get('m1_start')
         else:
             check_start = 0
         for cell_node_index in range(check_start, len(cell_node_line)):
-            if cell_node_line[cell_node_index].cell.phase == 'S':
-                if self.check_s_start(cell_node_index, cell_node_line):
+            if cell_node_line[cell_node_index].cell.cell_type == 'S':
+                if self.check_ctype_start('S', cell_node_index, cell_node_line):
                     lineage['s_start'] = s_start_index = cell_node_index
                     break
         if s_start_index is not None:
             for cell_node_index_2 in range(s_start_index, len(cell_node_line)):
-                if cell_node_line[cell_node_index_2].cell.phase != 'S':
-                    if self.check_s_exit(cell_node_index_2, cell_node_line):
+                if cell_node_line[cell_node_index_2].cell.cell_type != 'S':
+                    if self.check_ctype_exit('S', cell_node_index_2, cell_node_line):
                         lineage['s_exit'] = s_exit_index = cell_node_index_2
                         break
 
         if s_start_index is not None:
             if s_exit_index is not None:
                 end = s_exit_index
             else:
                 end = len(cell_node_line)
             for cell_node_index_s in range(s_start_index, end):
-                cell_node_line[cell_node_index_s].cell.phase = 'S'
+                cell_node_line[cell_node_index_s].cell.cell_type = 'S'
         self.parse_s_flag[root] = True
 
     def parse_g1_g2(self, lineage: dict, root: CellNode, lineage_index=None):
         """Accurately distinguish G1/G2 into G1, G2"""
         cell_node_line = lineage.get('cells')
         g1_start_index = None
         g1_exit_index = None
@@ -246,34 +254,34 @@
         g2_exit_index = None
         m1_start = lineage.get('m1_start')
         m2_start = lineage.get('m2_start')
         if not self.parse_s_flag[root]:
             self.parse_s(lineage, root)
         if lineage.get('s_start') is not None:
             # 1. track starts from  S
-            # 2. track starts from G1 phase
+            # 2. track starts from G1 cell_type
             # 3. The track starts from the M1
             g1_exit_index = lineage.get('s_start')
             if m1_start is not None:
                 g1_start_index = 3
             else:
                 g1_start_index = 0
             if lineage.get('s_exit') is not None:
                 g2_start_index = lineage.get('s_exit')
                 if m2_start is not None:
                     g2_exit_index = m2_start
                 else:
                     g2_exit_index = len(cell_node_line)
 
         else:
-            # cells are not in S phase
-            # 1. The track starts from the M1 period and does not enter the S phase
-            # 2. The track starts from the G1 phase and does not enter the S phase
-            # 3. The track starts from the G2 period and enters the M2 phase
-            # 3. The track starts from the G2 period and does not enter the M2 phase
+            # cells are not in S cell_type
+            # 1. The track starts from the M1 period and does not enter the S cell_type
+            # 2. The track starts from the G1 cell_type and does not enter the S cell_type
+            # 3. The track starts from the G2 period and enters the M2 cell_type
+            # 3. The track starts from the G2 period and does not enter the M2 cell_type
             if m2_start is not None:
                 if len(cell_node_line) > 5:
                     g2_start_index = 0
                     g2_exit_index = m2_start
             elif m1_start is not None:
                 g1_start_index = 3
                 g1_exit_index = len(cell_node_line)
@@ -292,50 +300,50 @@
         if g1_start_index is not None:
             lineage['g1_start'] = g1_start_index
             if g1_exit_index is not None:
                 end = g1_exit_index
             else:
                 end = len(cell_node_line)
             for cell_node_index_g1 in range(g1_start_index, end):
-                cell_node_line[cell_node_index_g1].cell.phase = 'G1'
+                cell_node_line[cell_node_index_g1].cell.cell_type = 'G1'
         if g2_start_index is not None:
             lineage['g2_start'] = g2_start_index
             if g2_exit_index is not None:
                 end_2 = g2_exit_index
             else:
                 end_2 = len(cell_node_line)
             for cell_node_index_g2 in range(g2_start_index, end_2):
-                cell_node_line[cell_node_index_g2].cell.phase = 'G2'
+                cell_node_line[cell_node_index_g2].cell.cell_type = 'G2'
 
     def parse_mitosis_error(self, lineage: dict, root: CellNode, lineage_index=None):
         """
-        If the two daughter cells after division are not matched, all subsequent cells will be in the M phase.
+        If the two daughter cells after division are not matched, all subsequent cells will be in the M cell_type.
         At this time, it should be corrected to G1 within a certain period of time.
         """
         cell_node_line = lineage.get('cells')
         m1_start = lineage.get('m1_start')
         m2_start = lineage.get('m2_start')
         m_count = 30
         if m1_start is not None:
             m_start = m1_start
         elif m2_start is not None:
             m_start = m2_start
         else:
             return
         for index in range(m_start, len(cell_node_line)):
-            if cell_node_line[index].cell.phase == 'M':
+            if cell_node_line[index].cell.cell_type == 'M':
                 m_count -= 1
                 if m_count < 0:
-                    cell_node_line[index].cell.phase = 'G1'
+                    cell_node_line[index].cell.cell_type = 'G1'
 
-    def set_cell_id(self, lineage: dict, root: CellNode, linage_index):
+    def set_cell_id(self, lineage: dict, root: CellNode, lineage_index):
         cell_node_line = lineage.get('cells')
-        branch_id = linage_index
+        branch_id = lineage_index
         cell_id = str(self.tree.track_id) + '_' + str(branch_id)
-        if linage_index == 0:
+        if lineage_index == 0:
             root.cell.set_cell_id(cell_id)
             root.cell.set_branch_id(branch_id)
             lineage['parent'] = root
         else:
             parent = lineage['parent']
             parent.cell.set_cell_id(parent.cell.cell_id)
             # parent.cell.set_cell_id(cell_id)
@@ -352,68 +360,129 @@
         self.parse_g1_g2(lineage, root, linage_index)
         self.parse_mitosis_error(lineage, root, linage_index)
         self.set_cell_id(lineage, root, linage_index)
 
     def parse_lineage_branch_id(self, lineage, branch_id):
         pass
 
+    def smooth_type(self, cell_lineage, root, lineage_index):
+        if N_CLASS and CLASS_NAME:
+            if len(CLASS_NAME) != N_CLASS:
+                logging.error('The number of category names and category numbers is not equal, '
+                              'try to change N_CLASS OR CLASS_NAME')
+                return
+        if CLASS_NAME:
+            if CLASS_NAME == ['G1', 'S', 'G2', 'M']:
+                self.parse_lineage_phase(cell_lineage, root, lineage_index)
+                return
+            else:
+                class_name = CLASS_NAME
+        elif N_CLASS:
+            class_name = set()
+            for cell in cell_lineage.get('cells'):
+                class_name.add(cell.cell.cell_type)
+        else:
+            logging.info('N_CLASS and CLASS_NAME not provided, ignore the whole process')
+            return
+        resolved_index_map = {}
+        for ctype in class_name:
+            cell_node_line = cell_lineage.get('cells')
+            check_start = 0
+            start_index = None
+            exit_index = None
+            for cell_node_index in range(check_start, len(cell_node_line)):
+                if cell_node_line[cell_node_index].cell.cell_type == ctype:
+                    if self.check_ctype_start(ctype, cell_node_index, cell_node_line):
+                        cell_lineage[f'{ctype}_start'] = start_index = cell_node_index
+                        break
+            if start_index is not None:
+                for cell_node_index_2 in range(start_index, len(cell_node_line)):
+                    if cell_node_line[cell_node_index_2].cell.cell_type != ctype:
+                        if self.check_ctype_exit(ctype, cell_node_index_2, cell_node_line):
+                            cell_lineage[f'{ctype}_exit'] = exit_index = cell_node_index_2 + 1
+                            break
+            if start_index is not None:
+                if exit_index is not None:
+                    end = exit_index
+                else:
+                    end = len(cell_node_line)
+                resolved_index_map[ctype] = start_index
+                for cell_node_index in range(start_index, end):
+                    cell_node_line[cell_node_index].cell.cell_type = ctype
+        if 0 not in resolved_index_map.values():
+            if not resolved_index_map:
+                type_count = []
+                for cell in cell_lineage.get('cells'):
+                    type_count.append(cell.cell.cell_type)
+                counter = Counter(type_count)
+                resolved_type = counter.most_common(1)[0][0]
+                for cell in cell_lineage.get('cells'):
+                    cell.cell.cell_type = resolved_type
+            else:
+                resolved_type = min(resolved_index_map, key=resolved_index_map.get)
+                for cell in cell_lineage.get('cells')[:min(resolved_index_map.values())]:
+                    cell.cell.cell_type = resolved_type
+        self.smooth_flag[root] = True
+
 
 def pares_single_tree(tree: TrackingTree):
     parser = TreeParser(tree)
     parser.search_root_node()
     parser.get_lineage_dict()
-
     for node_index in range(len(parser.root_parent_list)):
         cell_lineage = parser.lineage_dict.get(parser.root_parent_list[node_index])
-        if tree.get_node(tree.root).cell.phase is None:
-            parser.set_cell_id(cell_lineage, root=parser.root_parent_list[node_index], linage_index=node_index)
+        if tree.get_node(tree.root).cell.cell_type is None:
+            parser.set_cell_id(cell_lineage, root=parser.root_parent_list[node_index], lineage_index=node_index)
         else:
-            parser.parse_lineage_phase(cell_lineage, root=parser.root_parent_list[node_index], linage_index=node_index)
+            # parser.parse_lineage_phase(cell_lineage, root=parser.root_parent_list[node_index], linage_index=node_index)
+            parser.smooth_type(cell_lineage, root=parser.root_parent_list[node_index], lineage_index=node_index)
+            parser.set_cell_id(cell_lineage, root=parser.root_parent_list[node_index], lineage_index=node_index)
+            # print(cell_lineage)
     return parser
 
 
 def run_track(annotation, track_range=None, dic=None, mcy=None, speed_filename=None):
     tracker = Tracker(annotation, dic=dic, mcy=mcy)
     if track_range:
         tracker.track(range=track_range, speed_filename=speed_filename)
     else:
         tracker.track()
     parser_dict = {}
     for tree in tracker.trees:
-        try:
-            parser = pares_single_tree(tree)
-            parser_dict[tree] = parser
-        except:
-            continue
+        parser = pares_single_tree(tree)
+        parser_dict[tree] = parser
     tracker.parser_dict = parser_dict
     return tracker
 
 
 def track_tree_to_table(tracker: Tracker, filepath):
     """Export track result to table"""
-    track_detail_columns = ['frame_index', 'track_id', 'cell_id', 'parent_id', 'center_x', 'center_y', 'phase',
+    track_detail_columns = ['frame_index', 'track_id', 'cell_id', 'parent_id', 'center_x', 'center_y', 'cell_type',
                             'mask_of_x_points', 'mask_of_y_points']
     track_detail_dataframe = pd.DataFrame(columns=track_detail_columns)
 
     def generate_series(cell_lineage):
         cell_nodes = cell_lineage.get('cells')
         parent = cell_lineage.get('parent')
         series_list = []
         new_nodes = []
         before_index = 0
         current_index = 1
+        if len(cell_nodes) == 1:
+            new_nodes.append(cell_nodes[0])
         for cell_node_index in range(len(cell_nodes) - 1):
             before_node = cell_nodes[before_index]
             current_node = cell_nodes[current_index]
             new_nodes.append(before_node)
             if current_node.cell.frame - before_node.cell.frame != 1:
                 for frame in range(before_node.cell.frame + 1, current_node.cell.frame):
                     # gap_cell = deepcopy(before_node.cell)
                     # gap_cell.frame = frame
-                    gap_cell = Cell(position=before_node.cell.position, phase=before_node.cell.phase, frame_index=frame)
+                    gap_cell = Cell(position=before_node.cell.position, cell_type=before_node.cell.cell_type,
+                                    frame_index=frame)
                     gap_cell.set_track_id(before_node.cell.track_id, 1)
                     gap_cell.set_cell_id(before_node.cell.cell_id)
                     gap_cell.set_branch_id(before_node.cell.branch_id)
                     gap_node = CellNode(gap_cell)
                     new_nodes.append(gap_node)
             elif current_index == len(cell_nodes) - 1:
                 new_nodes.append(current_node)
@@ -424,27 +493,28 @@
 
         # for node in cell_nodes:
         # print(new_nodes)
         for node in new_nodes:
             col = [node.cell.frame, node.cell.track_id,
                    node.cell.cell_id, parent.cell.cell_id,
                    node.cell.center[0], node.cell.center[1],
-                   node.cell.phase,
+                   node.cell.cell_type,
                    node.cell.position[0], node.cell.position[1]]
             s = pd.Series(dict(zip(track_detail_columns, col)))
             series_list.append(s)
         return series_list, new_nodes
 
     parser_dict = tracker.parser_dict
     for tree in parser_dict:
+        if tree.track_id == 4:
+            p = parser_dict[tree]
         parser = parser_dict[tree]
         for node_index in parser.root_parent_list:
             cell_lineage = parser.lineage_dict.get(node_index)
             series_list, new_node_list = generate_series(cell_lineage)
-
             for series in series_list:
                 track_detail_dataframe = track_detail_dataframe._append(series, ignore_index=True)
     fname = filepath
     track_detail_dataframe.to_csv(fname, index=False)
 
 
 def track_trees_to_json(tracker: Tracker, output_fname, xrange, basename=None):
@@ -453,18 +523,18 @@
         prefix = 'mcy'
     else:
         prefix = basename
 
     def update_region(node):
         # print(type(node))
         region = node.cell.region
-        phase = node.cell.phase
+        phase = node.cell.cell_type
         track_id = node.cell.track_id
         cell_id = node.cell.cell_id
-        region['region_attributes']['phase'] = phase
+        region['region_attributes']['cell_type'] = phase
         region['region_attributes']['track_id'] = track_id
         region['region_attributes']['cell_id'] = cell_id
         region['region_attributes']['id'] = track_id
         node.cell.set_region(region)
 
     result = {}
     frame_map = {}
@@ -491,22 +561,64 @@
             if image_name is not None:
                 tmp_frame = result.get(image_name)
                 tmp_frame['regions'].append(region)
     with open(output_fname, 'w') as f:
         json.dump(result, f)
 
 
-def track_tree_to_MOT(tracker: Tracker, output_fname, xrange, basename=None):
-    """Export track result as MOT format"""
+def track_tree_to_TRA(tracker: Tracker, output_fname=None, xrange=None, basename=None):
+    """Export track result as TRA format"""
+
+    TRA = []
+    parser_dict = tracker.parser_dict
+    for tree in parser_dict:
+        parser = parser_dict[tree]
+        for node_index in parser.root_parent_list:
+            cell_lineage = parser.lineage_dict.get(node_index)
+            cells = cell_lineage.get('cells')
+            parent = cell_lineage['parent']
+            branch_id = cell_lineage['branch_id']
+            L = int(cells[0].cell.cell_id.replace('_', ''))
+            B = cells[0].cell.frame
+            E = cells[-1].cell.frame
+            if branch_id == 0:
+                P = 0
+            else:
+                P = int(parent.cell.cell_id.replace('_', ''))
+            line = f'{L} {B} {E} {P}\n'
+            TRA.append(line)
+    if output_fname:
+        with open(output_fname, 'w') as f:
+            f.writelines(TRA)
+
+
+def track_tree_to_mask(tracker, width, height, output_dir):
     parser_dict = tracker.parser_dict
+    cell_each_frame = {}  # {frame: cell_list}
     for tree in parser_dict:
         parser = parser_dict[tree]
         for node_index in parser.root_parent_list:
             cell_lineage = parser.lineage_dict.get(node_index)
-            pass
+            cells = cell_lineage.get('cells')
+            for cell in cells:
+                if cell.cell.frame not in cell_each_frame:
+                    cell_each_frame[cell.cell.frame] = {cell}
+                else:
+                    cell_each_frame[cell.cell.frame].add(cell)
+    if not os.path.exists(output_dir):
+        os.mkdir(output_dir)
+    for frame in cell_each_frame.keys():
+        fname = os.path.join(output_dir, f"mask" + f"{frame}".zfill(3) + ".tif")
+        mask_arr = np.zeros((height, width), dtype=np.uint16)
+        for cell in cell_each_frame[frame]:
+            contours = cell.cell.contours
+            L = int(cell.cell.cell_id.replace('_', ''))
+            cv2.fillConvexPoly(mask_arr, contours, (L))
+        tifffile.imwrite(fname, mask_arr)
+
 
 
 def run(annotation, output_dir, basename, track_range=None, save_visualize=True, visualize_background_image=None,
         dic=None, mcy=None, track_to_json=True):
     if track_range is None:
         if type(annotation) is str:
             with open(annotation, encoding='utf-8') as f:
@@ -514,39 +626,49 @@
         elif type(annotation) is dict:
             data = annotation
         else:
             raise ValueError(f"annotation type error {type(annotation)}")
         xrange = len(data)
     else:
         xrange = track_range + 2
-    speed_output_filename = os.path.join(output_dir, 'track_speed.csv')
+    if config.RECORD_SPEED:
+        speed_output_filename = os.path.join(output_dir, 'track_speed.csv')
+    else:
+        speed_output_filename = None
     tracker = run_track(annotation, track_range=xrange - 2, dic=dic, mcy=mcy, speed_filename=speed_output_filename)
     track_table_fname = os.path.join(output_dir, 'track.csv')
     track_visualization_fname = os.path.join(output_dir, 'track_visualization.tif')
     track_json_fname = os.path.join(output_dir, 'result_with_track.json')
-    tracktree_save_path = os.path.join(output_dir, 'tracktree')
+    tracktree_save_path = os.path.join(output_dir, 'TrackTree')
     track_tree_to_table(tracker, track_table_fname)
     tracker.track_tree_to_json(tracktree_save_path)
+    track_tree_to_TRA(tracker, os.path.join(output_dir, 'TRA.txt'))
+    image_width, image_height = imagesize.get(mcy)
+    track_tree_to_mask(tracker, image_width, image_height, os.path.join(output_dir, 'mask'))
     if track_to_json:
         track_trees_to_json(tracker, track_json_fname, xrange=xrange, basename=basename)
     if save_visualize:
         tracker.visualize_to_tif(visualize_background_image, track_visualization_fname, tracker.trees, xrange=xrange)
 
 
 if __name__ == '__main__':
-    annotation = r'G:\paper\evaluate_data\copy_of_1_xy10\result-GT.json'
-    mcy_img = r'G:\paper\evaluate_data\copy_of_1_xy10\mcy.tif'
-    dic_img = r'G:\paper\evaluate_data\copy_of_1_xy10\dic.tif'
-    table = r'G:\paper\evaluate_data\copy_of_1_xy10\track-table-test.csv'
-    visual = r'G:\paper\evaluate_data\copy_of_1_xy10\tracking_visualize-test.tif'
-    tracker = run_track(r'G:\paper\evaluate_data\copy_of_1_xy10\result-GT.json', track_range=300)
-    background_filename_list = [os.path.join(r'G:\paper\evaluate_data\copy_of_1_xy10\tif-seq', i) for i in
-                                os.listdir(r'G:\paper\evaluate_data\copy_of_1_xy10\tif-seq')]
+    # annotation = r'G:\杂项\example\example-annotation.json'
+    # mcy_img = r'G:\杂项\example\example-image.tif'
+    # dic_img = r'G:\杂项\example\example-bf.tif'
+    annotation = r"G:\CTC dataset\Fluo-N2DL-HeLa\Fluo-N2DL-HeLa\01_ST\test.json"
+    mcy_img = r"G:\CTC dataset\Fluo-N2DL-HeLa\Fluo-N2DL-HeLa\01_ST\SEG.tif"
+    dic_img = r"G:\CTC dataset\Fluo-N2DL-HeLa\Fluo-N2DL-HeLa\01_ST\SEG.tif"
+    # tracker = run_track(r'G:\paper\evaluate_data\copy_of_1_xy10\result-GT.json', track_range=10)
+    # tracker = run_track(annotation, track_range=30)
+    # background_filename_list = [os.path.join(r'G:\paper\evaluate_data\copy_of_1_xy10\tif-seq', i) for i in
+    #                             os.listdir(r'G:\paper\evaluate_data\copy_of_1_xy10\tif-seq')]
     # print(background_filename_list)
-    print(tracker.trees[9])
-    tracker.visualize_single_tree(tree=tracker.trees[51],
-                                  save_dir=r'G:\paper\evaluate_data\copy_of_1_xy10\single_tree_visualize',
-                                  background_filename_list=background_filename_list, xrange=300)
-
-    # run(annotation=fjson, output_dir=result_save_path, track_range=track_range, dic=fbf, mcy=fpcna,
-    #                 save_visualize=export_visualization, visualize_background_image=fpcna,
-    #                 track_to_json=track_to_json, basename=basename)
+    # for i in tracker.trees:
+    #     print(i)
+    # tracker.visualize_single_tree(tree=tracker.trees[51],
+    #                               save_dir=r'G:\paper\evaluate_data\copy_of_1_xy10\single_tree_visualize',
+    #                               background_filename_list=background_filename_list, xrange=10)
+
+    run(annotation=annotation, output_dir=r"G:\CTC dataset\Fluo-N2DL-HeLa\Fluo-N2DL-HeLa\01_ST",
+        track_range=None, dic=None, mcy=mcy_img,
+        save_visualize=True, visualize_background_image=mcy_img,
+        track_to_json=True, basename=r'man_seg')
```

### Comparing `SC-Track-0.0.4/SCTrack/sctrack.py` & `SC-Track-0.0.5/SCTrack/sctrack.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,51 +7,52 @@
 
 import argparse
 import logging
 import os
 import sys
 import time
 import imagesize
-from SCTrack import track
+from SCTrack import track, config
 
 
 def main():
     logging.basicConfig(format="%(asctime)s %(levelname)s: %(message)s", datefmt="%Y-%m-%d %H:%M:%S",
                         level=logging.INFO)
 
     parser = argparse.ArgumentParser(description="", add_help=False)
     help_content = """
         Welcome to use SC-Track!
         using this script to auto tracking the single cell images and identify each cell's type.\n
         usage:
-            python main.py -image <image image filepath>  -bf <bf image filepath> -o [optional] <output result filepath> 
+            sctrack -i <image filepath> -a <annotation filepath, json annotation or segmentation mask filepath>  
+            -bf[optional] <bright field image filepath> -o [optional] <output result filepath> 
             -t [optional]
     """
 
     parser.add_argument("-h", "--help", action="help", help=help_content)
     parser.add_argument('-i', "--image", default=False, help="input image filepath for nuclear")
     parser.add_argument('-o', "--output", default=False, help='output json file path')
     parser.add_argument('-bf', "--bf", default=False, help='input image filepath of bright field')
     parser.add_argument('-ot', "--ot", default=False, help='tracking output result saved dir')
     parser.add_argument('-a', "--annotation", default=False, help='annotation file path, json file or tiff mask file.')
     parser.add_argument('-r', "--range", default=False,
-                        help='tracking frame range, default is None, means tracking whole timelapse')
+                        help='tracking frame range, default is None, means tracking the whole timelapse')
 
     args = parser.parse_args()
 
     if len(sys.argv) < 2:
         parser.print_help()
         sys.exit(0)
 
     if args.image is False:
         logging.warning("Raw image not be given, so that the visualization result will not be support!")
         visualization = False
     else:
         image = args.image
-        visualization = True
+        visualization = config.EXPORT_TRACKING_VISUALIZATION
         image_width, image_height = imagesize.get(image)
         bf = args.bf
 
     if args.annotation is False:
         logging.error(
             'You must provide segmentation annotation file for tracking, support json format or mask tif format.')
         sys.exit(-1)
```

### Comparing `SC-Track-0.0.4/SCTrack/t_error.py` & `SC-Track-0.0.5/SCTrack/t_error.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+import logging
+
+
 class InsertError(Exception):
     def __init__(self, value):
         self.value = value
 
     def __str__(self):
         return f"Insert Error: {self.value}!"
```

### Comparing `SC-Track-0.0.4/SCTrack/template.py` & `SC-Track-0.0.5/SCTrack/template.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,15 @@
         {
             "name": "polygon",
             "all_points_x": [],
             "all_points_y": []
         },
     "region_attributes":
         {
-            "phase": None,
+            "cell_type": None,
             "cell_id": None,
             'track_id': None,
         }
 }
 
 FRAME_TMP =  {
         "filename": None,
```

### Comparing `SC-Track-0.0.4/SCTrack/track.py` & `SC-Track-0.0.5/SCTrack/track.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+# coding=utf-8
+
 from __future__ import annotations
 
 import logging
 import os.path
 from SCTrack import reclassification
 from SCTrack.utils import mask_to_json
 
@@ -34,9 +36,21 @@
     result_save_path = os.path.join(fout, 'tracking_output')
     if not os.path.exists(result_save_path):
         os.makedirs(result_save_path)
     reclassification.run(annotation=annotation, output_dir=result_save_path, track_range=track_range, dic=fbf,
                          mcy=fimage,
                          save_visualize=export_visualization, visualize_background_image=fimage,
                          track_to_json=track_to_json, basename=basename)
-#
-# start_track(r'G:\20x_dataset\evaluate_data\src01\result-GT.json',r'G:\20x_dataset\evaluate_data\src01', 'mcy', 40, fpcna=r'G:\20x_dataset\evaluate_data\src01\mcy.tif')
+
+
+if __name__ == '__main__':
+    i = 8
+    annotation = rf"G:\paper\test\Data{i}\SEG.tif"
+    mcy_img = rf"G:\paper\test\Data{i}\01.tif"
+    start_track(annotation, rf"G:\paper\test\Data{i}", 'mcy', 1000,
+                mcy_img)
+
+    # annotation = r"G:\杂项\example\example-annotation.json"
+    # mcy_img = r"G:\杂项\example\example-image.tif"
+    # dic_img = r'G:\杂项\example\example-bf.tif'
+    # start_track(annotation, r"G:\杂项\example", 'mcy', 30,
+    #             mcy_img)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `SC-Track-0.0.4/SCTrack/tracker.py` & `SC-Track-0.0.5/SCTrack/tracker.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-
 from __future__ import annotations
 
 import csv
 import os
 import sys
 import time
 from collections import deque
 from concurrent.futures import ThreadPoolExecutor
 import shapely
 
-
 sys.path.append('.')
 sys.path.append('..')
 sys.path.append('../../')
+sys.setrecursionlimit(3000)
 
 from functools import wraps, lru_cache
 import warnings
 from typing import List
 import tifffile
 import numpy as np
 import cv2
@@ -27,15 +26,14 @@
 
 from SCTrack.utils import convert_dtype, readTif
 from SCTrack.base import Cell, Rectangle, Vector, TreeStatus, CellStatus
 from SCTrack.t_error import InsertError, MitosisError, NodeExistError, ErrorMatchMitosis, StatusError
 from SCTrack.feature import FeatureExtractor, feature_extract
 from SCTrack import config
 
-
 TEST = False
 TEST_INDEX = None
 CELL_NUM = 0
 
 
 class Checker(object):
     """
@@ -96,16 +94,16 @@
         if key not in cls._instance_:
             cls._instance_[key] = super().__new__(cls)
             cls._instance_[key].status = None
             cls._instance_[key].track_id = None
             cls._instance_[key].__branch_id = None
             cls._instance_[key].parent = None
             cls._instance_[key].childs = []
-            cls._instance_[key].add_tree = False  # 如果被添加到TrackingTree中，设置为True
-            cls._instance_[key].life = 5  # 每个分支初始生命值为5，如果没有匹配上，或者利用缺省值填充匹配，则-1，如如果生命值为0，则该分支不再参与匹配
+            cls._instance_[key].add_tree = False  # if adding to the TrackingTree，set as True
+            cls._instance_[key].life = 5
             cls._instance_[key]._init_flag = False
         return cls._instance_[key]
 
     def __init__(self, cell: Cell, node_type='cell', fill_gap_index=None):
         if not self._init_flag:
             self.cell = cell
             if node_type == 'gap':
@@ -303,39 +301,42 @@
             union = Rectangle(max(rect1.x_min, rect2.x_min), min(rect1.x_max, rect2.x_max),
                               max(rect1.y_min, rect2.y_min), min(rect1.y_max, rect2.y_max))
             return union.area / intersection.area
 
     def calcIoU(self, cell_1: Cell, cell_2: Cell):
         """
         Calculate IoU of two cells.
+        First, try to calculate the IoU of the contour. If it is not possible to calculate,
+        then change to calculating the IoU of the bounding box.
         return value range: float(0-1)
         """
         poly1 = cell_1.polygon
         poly2 = cell_2.polygon
 
         try:
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
                 intersection = poly1.intersection(poly2)
                 union = poly1.union(poly2)
+                if union.area == 0:
+                    return 0
+                elif poly1.contains(poly2) or poly2.contains(poly1):
+                    return 1
+                else:
+                    return intersection.area / union.area
         except shapely.errors.GEOSException:
             return self.calcIoU_roughly(cell_1, cell_2)
-        if union.area == 0:
-            return 0
-        elif poly1.contains(poly2) or poly2.contains(poly1):
-            return 1
-        else:
-            return intersection.area / union.area
 
     def calcCosDistance(self, cell_1: Cell, cell_2: Cell):
         """
         Calculate the cosine distance of two cells
         Return value range: float[0, 2]
         The smaller the distance, the more similar it is, scaled to [0, 1) by the arctangent function
-        The return value is the cosine value after normalization [0, π/2]. The smaller the return value, the lower the similarity
+        The return value is the cosine value after normalization [0, π/2].
+        The smaller the return value, the lower the similarity
         """
         dist = cell_1.vector.cosDistance(cell_2.vector)
         return np.cos(np.arctan(dist) / (np.pi / 2))
 
     def calcCosSimilar(self, cell_1: Cell, cell_2: Cell):
         """
         Calculate the cosine similarity of the center points of two cells
@@ -388,16 +389,17 @@
         else:
             return 0
 
     def compareShapeSimilar(self, cell_1: Cell, cell_2: Cell):
         """
         Calculate the contour similarity of two cells
         Return value range: float(0, 1)
-        The smaller the score value, the greater the similarity, and the inversion operation can be performed
-        The return value is the cosine value after normalization [0, π/2]
+        The smaller the score value, the greater the similarity, and the inversion operation can be performed.
+        (The return value is the cosine value after normalization [0, π/2], no longer do this change, directly return
+        the score.)
         """
         score = cv2.matchShapes(cell_1.contours, cell_2.contours, 1, 0.0)
         # return np.cos(self.normalize(score))
         return score
 
     def __str__(self):
         return f"Match object at {id(self)}"
@@ -436,15 +438,19 @@
         """filter candidates"""
 
         # filtered_candidates = [cell for cell in cells if cell in child]
         filtered_candidates = []
         for cell in cells:
             if cell in child and cell.is_accurate_matched is False:
                 if self.matcher.calcEuclideanDistance(cell, child) < child.r_long or \
-                        self.matcher.calcIoU(cell, child) > 0.2:
+                        self.matcher.calcIoU(cell, child) > 0:
+                    filtered_candidates.append(cell)
+        if not filtered_candidates:
+            for cell in cells:
+                if cell in child and cell.is_accurate_matched is False:
                     filtered_candidates.append(cell)
 
         return filtered_candidates
 
     def match_candidates(self, child: Cell, before_cell_list: List[Cell]):
         """match candidates"""
         return self._filter(child, before_cell_list)
@@ -476,39 +482,35 @@
         """
         Match multiple candidates. Calling this function means that there is more than one candidate, and this method
         calculates the matching degree of each candidate
         The return value is a dictionary in the form of {Cell: similar_dict}
         """
         matched = {}
         for i in unmatched_child_list:
-            # if i.is_be_matched :
-            #     if i.status.exist_mitosis_time < 50:
-            #         continue
             similar = self.match_similar(parent, i)
-            matched[i] = similar
+            if similar['IoU'] > 0:
+                matched[i] = similar
         return matched
 
-    def is_mitosis_start(self, pre_parent: Cell, last_leaves: List[Cell], area_size_t=1.5, iou_t=0.5):
+    def is_mitosis_start(self, pre_parent: Cell, last_leaves: List[Cell], area_size_t=1.5, iou_t=0.3):
         """
-        Determine whether a cell enters the M phase. The basic criterion is that when a cell enters mitosis, its volume
-        increases and the number of candidate regions increases. If the cell successfully enters the M phase, return a
+        Determine whether a cell enters the M cell_type. The basic criterion is that when a cell enters mitosis, its volume
+        increases and the number of candidate regions increases. If the cell successfully enters the M cell_type, return a
         dict containing information about the last frame of G2 and the first frame of M. Otherwise, return False.
          """
         match_score = {}
         for i in last_leaves:
             if self.match_similar(pre_parent, i).get('IoU') >= iou_t:
                 match_score[i] = self.match_similar(pre_parent, i)
         for child_cell in match_score:
-            # if Rectangle(*parent.bbox).isInclude(Rectangle(*child_cell.bbox)) or (
-            #         (child_cell.area / parent.area) >= area_size_t):
             if (child_cell.area / pre_parent.area) >= area_size_t:
                 return {'last_G2': pre_parent, 'first_M': child_cell}
         return False
 
-    def get_similar_sister(self, parent: Cell, matched_cells_dict: dict, area_t=0.7, shape_t=0.03, area_size_t=1.3,
+    def get_similar_sister(self, parent: Cell, matched_cells_dict: dict, area_t=0.6, shape_t=0.03, area_size_t=1.3,
                            iou_t=0.1):
         """Find the two most similar cells among multiple candidates as the daughter cells."""
         cell_dict_keys = list(matched_cells_dict.keys())
         cell_dict_keys.sort(key=lambda cell: cell.area, reverse=True)
 
         for cell in cell_dict_keys:
             # if matched_cells_dict[cell].get('IoU') < iou_t:
@@ -535,51 +537,43 @@
                     match_result[(cell_1, cell_2)] = score.get('area') + score.get('IoU')
         if match_result:
             max_score_cells = max(match_result, key=match_result.get)
             return max_score_cells
         else:
             raise MitosisError('cannot match the suitable daughter cells')
 
-    def select_mitosis_cells(self, parent: Cell, candidates_child_list: List[Cell], area_t=0.7, shape_t=0.05,
+    def select_mitosis_cells(self, parent: Cell, candidates_child_list: List[Cell], area_t=0.5, shape_t=0.05,
                              area_size_t=1.3):
         """
         If cell division occurs, select two daughter cells. When calling this method, make sure that cell division is
         highly likely to occur. If the return value is cell division, then it is necessary to check whether the areas
         of the two daughter cells are normal. If the area of one daughter cell is too large, it is considered a FP.
 
         :return ([cell_1, cell2], 'match status')
 
         """
 
         matched_candidates = self.match_duplicate_child(parent, candidates_child_list)
         checked_candidates = {}
         for i in matched_candidates:
             if i.is_be_matched:
-                if i.status.exist_mitosis_time < 50:
+                if i.status.exit_mitosis_time < config.ENTER_DIVISION_THRESHOLD:
                     continue
             checked_candidates[i] = matched_candidates[i]
         matched_cells_dict = self.check_iou(checked_candidates)
-        # matched_cells_dict = self.check_iou(matched_candidates)
         if not matched_cells_dict:
             raise MitosisError('not enough candidates')
         else:
             if len(matched_cells_dict) == 2:
                 cells = list(matched_cells_dict.keys())
-                # if max([i.area for i in
-                #         list(matched_cells_dict.keys())]) > parent.area * area_size_t:  # 如果母细胞太小了，不认为会发生有丝分裂，转向单项判断
-                #     raise MitosisError('The cell is too small to have cell division !')
-                # if self.matcher.calcAreaSimilar(cells[0], cells[1]) > area_t and self.matcher.compareShapeSimilar(
-                #         cells[0], cells[1]) < shape_t:
                 if self.matcher.calcAreaSimilar(cells[0], cells[1]) > area_t:
                     return cells, 'ACCURATE'
                 else:
-                    # raise MitosisError("not enough candidates, after matched.")
                     return cells, 'INACCURATE'
             else:
-                # max_two = heapq.nlargest(2, [sum(sm) for sm in matched_cells_dict.values()])  # 找到匹配结果中最大的两个值
                 try:
                     max_two = self.get_similar_sister(parent, matched_cells_dict)  # 找到匹配结果中最大的两个值
                 except MitosisError:
                     raise MitosisError("not enough candidates, after matched.")
                 better_sisters = []
                 for i in max_two:
                     better_sisters.append(i)
@@ -595,18 +589,16 @@
         For multiple IOU matching options, choose the one with a higher similarity. This is to distinguish overlapping
         cells rather than cell division. Note: the results of this method are not necessarily accurate and may result
         in mismatches due to cell crossing, which needs to be resolved in subsequent steps. In addition, if one cell is
         accurately matched, and the other cell has no match (i.e., not detected in the next frame during recognition),
         it should be filled as a predicted cell.
 
         """
-
         def calc_weight(candidate_score_dict):
             """Compute and dynamically update matching weights and matching results."""
-            result = {}
             # for cell in candidate_score_dict:
             #     score_dict = candidate_score_dict[cell]
             # value =  score_dict['IoU'] * self.WEIGHT.get('IoU') + \
             #        score_dict['shape'] * self.WEIGHT.get('shape') + score_dict['area'] * self.WEIGHT.get('area')
             selected_cell = None
             max_iou = 0.0
             min_distance = 100
@@ -638,49 +630,47 @@
             if not iou_above_threshold:
                 for cell, score_dict in candidate_score_dict.items():
                     iou = score_dict['IoU']
                     if iou > max_iou:
                         selected_cell = cell
                         max_iou = iou
             return selected_cell
-            # return max(result, key=result.get)
 
         candidates = {}
         for cell in score_dict:
             if score_dict[cell].get('IoU') > 0.5:
                 candidates[cell] = score_dict[cell]
         if not candidates:
             for cell in score_dict:
                 if score_dict[cell].get('IoU') > 0.1:
                     candidates[cell] = score_dict[cell]
         if not candidates:
             for cell in score_dict:
                 if score_dict[cell].get('IoU') > 0.0:
                     candidates[cell] = score_dict[cell]
         if not candidates:
+            if not score_dict:
+                return None
             for cell in score_dict:
                 candidates[cell] = sum(score_dict[cell].values())
-            try:
-                best = max(candidates, key=candidates.get)
-            except ValueError:
-                print(score_dict)
+            best = max(candidates, key=candidates.get)
+            return best
         else:
             best = calc_weight(candidates)
-        return best
+            return best
 
     def match_one(self, predict_child, candidates):
         if len(candidates) == 1:
-            # print('matched single:', self.calc_similar(parent, filtered_candidates[0]))
-            score = self.calc_similar(predict_child, candidates[0])
-            if score[0] > 0.5:
+            score = self.matcher.calcIoU(predict_child, candidates[0])
+            if score > 0.5:
                 return [(candidates[0], 'ACCURATE')]
-            elif score[0] > 0:
+            elif score > 0:
                 return [(candidates[0], 'INACCURATE')]
             else:
-                return None
+                return [(candidates[0], 'INACCURATE')]
         else:
             return False
 
     def check_iou(self, similar_dict):
         """
         Check the IoU to provide a basis for determining cell division. If there are less than 2 matching options
         with IoU > 0, return False. Otherwise, return these two cells.
@@ -695,68 +685,62 @@
         else:
             return matched
 
     def _match(self, parent: Cell, filter_candidates_cells: List[Cell], cell_track_status: TreeStatus):
         """
         Compare the overall similarity of two cells.
         """
-        # predict_child = self.predict_next_position(parent)
         predict_child = parent
         # filtered_candidates = self.match_candidates(predict_child, no_filter_candidates_cells)
         filtered_candidates = [cell for cell in filter_candidates_cells if cell.is_accurate_matched is False]
-        # print(filtered_candidates)
         if len(filtered_candidates) > 0:
             if not self.match_one(predict_child, filtered_candidates):  # 不只有一个选项
                 if self.match_one(predict_child, filtered_candidates) is None:
                     return
                 matched_candidates = self.match_duplicate_child(predict_child, filtered_candidates)
-                if len(matched_candidates) > 1:
+                if len(matched_candidates) > 1 and cell_track_status.exit_mitosis_time > 25:
                     cell_track_status.enter_mitosis(parent.frame)
                 if not cell_track_status.status.get('enter_mitosis'):
-                    # if parent.phase != 'M':
+                    if self.select_single_child(matched_candidates) is None:
+                        return
                     return {'matched_cell': [(self.select_single_child(matched_candidates), 'INACCURATE')],
                             'status': cell_track_status}
-                # elif not self.check_iou(matched_candidates):
-                #     return {'matched_cell': [(self.select_single_child(matched_candidates), 'ACCURATE')],
-                #             'status': cell_track_status}
                 else:
                     matched_result = []
                     try:
                         sisters, status = self.select_mitosis_cells(parent, filtered_candidates)  # 此时细胞一分为二
                         cell_track_status.exit_mitosis(parent.frame + 1)
                         for sister in sisters:
                             matched_result.append((sister, status))
 
                     except MitosisError as M:  # 细胞可能仍然处于M期，但是已经完成分开，或者只是被误判为M期
-                        matched_result.append((self.select_single_child(matched_candidates), 'INACCURATE'))
-                        # print(M)
+                        if self.select_single_child(matched_candidates):
+                            matched_result.append((self.select_single_child(matched_candidates), 'INACCURATE'))
                     except ErrorMatchMitosis as M2:
                         # 细胞可能不均等分裂
-                        matched_result.append((self.select_single_child(matched_candidates), 'INACCURATE'))
-                        # print(M2)
+                        if self.select_single_child(matched_candidates):
+                            matched_result.append((self.select_single_child(matched_candidates), 'INACCURATE'))
                     finally:
-                        return {'matched_cell': matched_result, 'status': cell_track_status}
+                        if matched_result:
+                            return {'matched_cell': matched_result, 'status': cell_track_status}
+                        return None
             else:
                 return {'matched_cell': self.match_one(predict_child, filtered_candidates), 'status': cell_track_status}
 
     def calc_sorted_value(self, parent: Cell, matched_cell):
         """Calculate the sorting value of a Cell object."""
 
         match_score = self.match_similar(parent, matched_cell)
         sort_value = match_score['IoU'] + 1 / (match_score['distance'] + 1e-5)
         return sort_value
 
     def add_child_node(self, tree, child_node: CellNode, parent_node: CellNode):
         try:
             tree.add_node(child_node, parent=parent_node)
             child_node.set_tree_status(tree.status)
-        # except TypeError as E:
-        #     print(E)
-        # except NodeExistError as E2:
-        #     print(E2)
         except treelib.exceptions.DuplicatedNodeIdError:
             pass
 
     def match_single_cell(self, tree: TrackingTree, current_frame: FeatureExtractor):
         """The implementation logic for tracking a single cell."""
 
         cells = current_frame.cells
@@ -766,81 +750,59 @@
             parent_dict = {parent: parent.frame for parent in parents}
             keys = [p for p in parents]
             if parent_dict[keys[0]] != parent_dict[keys[1]]:
                 min_parent = min(parent_dict, key=parent_dict.get)
                 parents.pop(min_parent)
         for parent in parents:
             # Two or more cells after cell division.
-            # print(f'\nparent cell math status: {parent.is_be_matched}')
             tree.m_counter -= 1
             if not tree.m_counter:
                 tree.m_counter = 5
                 tree.status.reset_M_count()
-            if parent.phase == 'M':
+            if parent.cell_type == 'M':
                 tree.status.add_M_count()
             if tree.status.predict_M_len >= 2:
                 tree.status.enter_mitosis(parent.frame - 3)
-
-            # predict_child = self.predict_next_position(parent)
             predict_child = parent
-
             filtered_candidates = self.match_candidates(predict_child, cells)
-            # filtered_candidates = list(candidates)
             before_parent = tree.get_parent(parents[parent])
             if before_parent:
                 if self.is_mitosis_start(before_parent.cell, [predict_child]):
-                    # if self.is_mitosis_start(predict_child, filtered_candidates):
                     tree.status.enter_mitosis(parent.frame)
             match_result = self._match(predict_child, filtered_candidates, tree.status)
             if match_result is not None:
                 child_cells = match_result.get('matched_cell')
                 for i in child_cells:
                     sort_value = self.calc_sorted_value(parent, i[0])
                     i[0].sort_value = sort_value
                 parent_node = CellNode(parent)
             else:
                 continue
             if len(child_cells) == 1:
-                # if child_cells[0][1] == 'PREDICTED':
-                #     current_frame.add_cell(child_cells[0][0])
-                #     child_node = CellNode(child_cells[0][0])
-                #     child_node.life -= 1
                 if child_cells[0][1] == 'ACCURATE':
-                    # candidates.remove(child_cells[0][0])
                     child_cells[0][0].is_accurate_matched = True
                     child_node = CellNode(child_cells[0][0])
                 else:
                     child_node = CellNode(child_cells[0][0])
-                    # child_cells[0][0].is_accurate_matched = True
-                # child_node.set_branch_id(parent_node.get_branch_id())
                 child_node.cell.set_branch_id(parent_node.cell.branch_id)
                 child_node.cell.set_status(tree.status)
                 child_node.cell.update_region(track_id=tree.track_id)
                 child_node.cell.update_region(branch_id=parent_node.cell.branch_id)
                 child_node.cell.set_match_status(child_cells[0][1])
-                # if child_node.life > 0:
                 self.add_child_node(tree, child_node, parent_node)
-                # child_node.branch_id = parent_node.branch_id
             else:
-                #     try:
-                #         assert len(child_cells) == 2
-                #     except AssertionError:
-                #         # self._match(predict_child, filtered_candidates, tree.status)
-                #         continue
-
                 for cell in child_cells:
                     new_branch_id = tree.branch_id_distributor()
                     cell[0].set_branch_id(new_branch_id)
                     cell[0].update_region(track_id=tree.track_id)
                     cell[0].update_region(branch_id=new_branch_id)
                     cell[0].set_match_status(cell[1])
                     child_node = CellNode(cell[0])
                     if cell[1] == 'ACCURATE':
                         cell[0].is_accurate_matched = True
-                        # candidates.remove(cell[0])
                     self.add_child_node(tree, child_node, parent_node)
         tree.status.add_exist_time()
 
 
 class Tracker(object):
     """
     Tracker object, which is the controller of the tracking process. It reads images frame by frame,
@@ -851,15 +813,15 @@
         self.matcher = Matcher()
         self.fe_cache = deque(maxlen=5)
         self.trees: List[TrackingTree] = []
         self.mcy = mcy
         self.dic = dic
         self.annotation = annotation
         self._exist_tree_id = []
-        self._available_id = 0
+        self._available_id = 1
         self.init_flag = False
         self.feature_ext = feature_extract(mcy=self.mcy, dic=self.dic, jsonfile=self.annotation)
         self.tree_maps = {}
         self.init_tracking_tree(next(self.feature_ext)[0])
         self.nodes = set()
         self.count = 0
         self.parser_dict = None
@@ -875,15 +837,14 @@
                 if self._available_id + i not in self._exist_tree_id:
                     self._available_id += (i + 1)
                     return self._available_id + i
                 i += 1
 
     def init_tracking_tree(self, fe: FeatureExtractor):
         """Initialize TrackingTree"""
-        # trees = []
         for i in fe.cells:
             tree = TrackingTree(track_id=self.id_distributor())
             i.sort_value = 1
             i.set_match_status('ACCURATE')
             i.set_track_id(tree.track_id, 1)
             i.set_branch_id(0)
             i.set_cell_id(str(i.track_id) + '-' + str(i.branch_id))
@@ -896,15 +857,14 @@
             i.set_match_status('ACCURATE')
             i.is_accurate_matched = True
             node.cell.set_status(TreeStatus(tree))
             tree.add_node(node)
             self.trees.append(tree)
             self.tree_maps[i] = tree
         self.init_flag = True
-        # self.trees = trees
         self.fe_cache.append(fe)
 
     def draw_bbox(self, bg1, cell: Cell, track_id, branch_id=None, phase=None):
         bbox = cell.bbox
         if len(bg1.shape) > 2:
             im_rgb1 = bg1
         else:
@@ -935,91 +895,68 @@
             child.update_speed(Vector(0, 0))
         else:
             speed = (child.vector - parent.vector)
             child.update_speed(speed)
 
     def get_current_tree(self, parent_cell: Cell):
         """Get the TrackingTree where the current parent cell is located"""
-        exist_trees = []  # 细胞可能存在的tree
+        exist_trees = []  # Possible trees include the cells
         for tree in self.trees:
             if parent_cell in tree.last_layer_cell:
                 exist_trees.append(tree)
         return exist_trees
 
     def add_node(self, child_node, parent_node, tree):
         if child_node not in tree:
-            # tree.add_node(child_node, parent=parent_node.identifier)
             tree.add_node(child_node, parent=parent_node)
             child_node.cell.set_status(CellStatus(tree))
         else:
             raise NodeExistError(child_node)
 
     def track_near_frame(self, fe1: FeatureExtractor, fe2: FeatureExtractor):
         """match adjacent frames"""
         cells = sorted(fe1.cells, key=lambda cell: cell.sort_value, reverse=True)
         for parent in cells:
-            # print(parent)
             trees = self.get_current_tree(parent)
             for tree in trees:
                 self.matcher.match_single_cell(tree, fe2)
 
     def track_near_frame_mult_thread(self, fe1: FeatureExtractor, fe2: FeatureExtractor):
         """Match Adjacent Frames, Multithreaded Beta"""
-
         def work(__parent: Cell):
             trees = self.get_current_tree(__parent)
             for tree in trees:
                 self.matcher.match_single_cell(tree, fe2)
 
         thread_pool_executor = ThreadPoolExecutor(max_workers=10, thread_name_prefix="track_")
         cells = sorted(fe1.cells, key=lambda cell: cell.sort_value, reverse=True)
-        # print([i.sort_value for i in cells])
         for parent in cells:
             thread_pool_executor.submit(work, parent)
         thread_pool_executor.shutdown(wait=True)
 
     def handle_duplicate_match(self, duplicate_match_cell):
         """Solve a cell is repeatedly matched by multiple cells"""
         child_node = CellNode(duplicate_match_cell)
         tmp = self.get_current_tree(duplicate_match_cell)
         parent0 = tmp[0].parent(child_node.nid)
-
         parent1 = tmp[1].parent(child_node.nid)
-        # if not (parent0.is_root() and parent1.is_root()):
-        #     parent00 = tmp[0].parent(parent0.nid)
-        #     parent11 = tmp[1].parent(parent1.nid)
-        #     tree_dict = {parent00: tmp[0], parent11: tmp[1]}
-        #     sm0 = self.matcher.match_similar(duplicate_match_cell, parent00.cell)
-        #     sm1 = self.matcher.match_similar(duplicate_match_cell, parent11.cell)
-        #     # match_score = {parent00: sm0['IoU'] + 1 / (sm0['distance'] + 1e-5),
-        #     #                parent11: sm1['IoU'] + 1 / (sm0['distance'] + 1e-5), }
-        #     match_score = {parent00: sm0['distance'],
-        #                    parent11: sm0['distance']}
-        #     error_parent = max(match_score)
-        # else:
         tree_dict = {parent0: tmp[0], parent1: tmp[1]}
         sm0 = self.matcher.match_similar(duplicate_match_cell, parent0.cell)
         sm1 = self.matcher.match_similar(duplicate_match_cell, parent1.cell)
-        # match_score = {parent0: sm0['IoU'] + 1 / (sm0['distance'] + 1e-5),
-        #                parent1: sm1['IoU'] + 1 / (sm0['distance'] + 1e-5), }
         match_score = {parent0: sm0['distance'],
                        parent1: sm1['distance']}
-        # truth_parent = max(match_score)
         error_parent = min(match_score)
-        # if len(tree_dict[truth_parent].nodes) < 3:
-        #     error_parent = truth_parent
         tree_dict[error_parent].remove_node(child_node.nid)
         return {error_parent: tree_dict[error_parent]}
 
     def rematch(self, fe1: FeatureExtractor, fe2: FeatureExtractor):
         """For the loss detection cells, re-match the upper and lower frames with the cache frame"""
         unmatched_list = [cell for cell in fe1.cells if cell.is_be_matched is False]
         if not unmatched_list:
             return
-        # for cell in fe1.cells:
         for cell in unmatched_list:
             current_frame = cell.frame
             if cell.is_be_matched is False:
                 handle_flag = False
                 trees = self.trees
                 wait_dict = {}
                 wait_tree_map = {}
@@ -1101,15 +1038,14 @@
         global writer, speed_f
         index = 0
         if speed_filename:
             speed_f = open(speed_filename, 'w', newline='')
             writer = csv.writer(speed_f)
             writer.writerow(['Iteration', 'Speed (it/s)'])
         for fe_before, fe_current, fe_next in tqdm(self.feature_ext, total=range, desc='tracking process'):
-            # self.track_near_frame(fe_before, fe_current)
             start_time = time.time()
             self.track_near_frame(fe_before, fe_current)
             # self.track_near_frame_mult_thread(fe_before, fe_current)
             self.fe_cache.append(fe_before)
             self.check_track(fe_before, fe_current, fe_next)
             del fe_before
 
@@ -1134,28 +1070,25 @@
             jsf = os.path.join(filepath, f'tree-{i.track_id}.json')
             if os.path.exists(jsf):
                 os.remove(jsf)
             i.save2file(jsf)
 
     def visualize_single_tree(self, tree, background_filename_list, save_dir, xrange=None):
         bg_fname = background_filename_list[:xrange + 2] if xrange else background_filename_list
-        print(bg_fname)
         images = list(map(lambda x: cv2.imread(x, -1), bg_fname))
         images_dict = dict(zip(list(range(len(bg_fname))), images))
-        print(images_dict.keys())
         for node in tree.expand_tree():
             frame = tree.nodes.get(node).cell.frame
             bbox = tree.nodes.get(node).cell.bbox
             img_bg = images_dict[frame]
-            phase = tree.nodes.get(node).cell.phase
+            phase = tree.nodes.get(node).cell.cell_type
             images_dict[frame] = self.draw_bbox(img_bg, tree.nodes.get(node).cell, tree.track_id,
                                                 tree.get_node(node).cell.branch_id, phase)
         for i in zip(bg_fname, list(images_dict.values())):
             fname = os.path.join(save_dir, os.path.basename(i[0]).replace('.tif', '.png'))
-            print(fname)
             cv2.imwrite(fname, i[1])
 
     def visualize_to_tif(self, background_mcy_image: str, output_tif_path, tree_list, xrange=None, single=False):
         """
         Visualize the tracking results, you can choose to save as a single tif file or multiple tif sequences
         :param background_mcy_image: background image for visualization
         :param output_tif_path: output file path
@@ -1194,15 +1127,15 @@
                     if frame > xrange:
                         continue
                 # bbox = i.nodes.get(node).cell.bbox
                 img_bg = images_dict.get(frame)
                 if img_bg is not None:
                     images_dict[frame] = self.draw_bbox(img_bg, i.nodes.get(node).cell, i.track_id,
                                                         i.get_node(node).cell.branch_id,
-                                                        phase=i.get_node(node).cell.phase)
+                                                        phase=i.get_node(node).cell.cell_type)
         if not single:
             if not (os.path.exists(output_tif_path) and os.path.isdir(output_tif_path)):
                 os.mkdir(output_tif_path)
             for i in tqdm(range(index), desc="save tracking visualization"):
                 fname = os.path.join(output_tif_path, f'{os.path.basename(output_tif_path)[:-4]}-{i:0>4d}.tif')
                 tifffile.imwrite(fname, images_dict[i])
         else:
@@ -1215,15 +1148,15 @@
                         break
                     tif.write(images_dict[i])
 
 
 def get_cell_line_from_tree(tree: TrackingTree, dic_path: str, mcy_path: str, savepath):
     """
     Obtain a complete cell sequence from the track tree, including cell images, dic and mcy dual channels, and cycles,
-    and the generated file name is named track_id-branch_id-frame-phase.tif"""
+    and the generated file name is named track_id-branch_id-frame-cell_type.tif"""
     if not os.path.exists(savepath):
         os.makedirs(savepath)
     save_mcy = os.path.join(savepath, 'mcy')
     save_dic = os.path.join(savepath, 'dic')
     if not os.path.exists(save_mcy):
         os.mkdir(save_mcy)
     if not os.path.exists(save_dic):
@@ -1232,24 +1165,13 @@
     dic = tifffile.imread(dic_path)
     for nid in tree.expand_tree():
         cell = tree.get_node(nid).cell
         y0, y1, x0, x1 = cell.bbox
         mcy_img = mcy[cell.frame][y0: y1, x0: x1]
         dic_img = dic[cell.frame][y0: y1, x0: x1]
         fname = str(tree.track_id) + '-' + str(cell.branch_id) + '-' + str(cell.frame) + '-' + str(
-            cell.phase[0]) + '.tif'
+            cell.cell_type[0]) + '.tif'
         tifffile.imwrite(os.path.join(save_mcy, fname), convert_dtype(mcy_img))
         tifffile.imwrite(os.path.join(save_dic, fname), convert_dtype(dic_img))
 
-        # break
 
 
-if __name__ == '__main__':
-    annotation = r'G:\20x_dataset\evaluate_data\copy_of_1_xy19\result-GT.json'
-    mcy_img = r'G:\20x_dataset\evaluate_data\copy_of_1_xy19\mcy.tif'
-    dic_img = r'G:\20x_dataset\evaluate_data\copy_of_1_xy19\dic.tif'
-    tracker = Tracker(annotation)
-    # tracker = Tracker(r'G:\20x_dataset\evaluate_data\copy_of_1_xy19\result-GT.json')
-    tracker.track(300)
-    for i in enumerate(tracker.trees):
-        get_cell_line_from_tree(i[1], dic_img, mcy_img,
-                                fr'G:\20x_dataset\evaluate_data\copy_of_1_xy19\cell_lines\{i[0]}')
```

### Comparing `SC-Track-0.0.4/SCTrack/utils.py` & `SC-Track-0.0.5/SCTrack/utils.py`

 * *Files identical despite different names*

### Comparing `SC-Track-0.0.4/SC_Track.egg-info/PKG-INFO` & `SC-Track-0.0.5/SC_Track.egg-info/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 00000000: 4d65 7461 6461 7461 2d56 6572 7369 6f6e  Metadata-Version
 00000010: 3a20 322e 310d 0a4e 616d 653a 2053 432d  : 2.1..Name: SC-
 00000020: 5472 6163 6b0d 0a56 6572 7369 6f6e 3a20  Track..Version: 
-00000030: 302e 302e 340d 0a53 756d 6d61 7279 3a20  0.0.4..Summary: 
+00000030: 302e 302e 350d 0a53 756d 6d61 7279 3a20  0.0.5..Summary: 
 00000040: 7369 6e67 6c65 2063 656c 6c20 7472 6163  single cell trac
 00000050: 6b69 6e67 2070 6163 6b61 6765 0d0a 486f  king package..Ho
 00000060: 6d65 2d70 6167 653a 2068 7474 7073 3a2f  me-page: https:/
 00000070: 2f67 6974 6875 622e 636f 6d2f 6672 6f7a  /github.com/froz
 00000080: 656e 6c65 6176 6573 2f53 432d 5472 6163  enleaves/SC-Trac
 00000090: 6b0d 0a41 7574 686f 723a 204c 6920 4368  k..Author: Li Ch
 000000a0: 656e 6778 696e 0d0a 4175 7468 6f72 2d65  engxin..Author-e
@@ -15,285 +15,325 @@
 000000e0: 6c69 6320 4c69 6365 6e73 6520 7633 2e30  lic License v3.0
 000000f0: 0d0a 5265 7175 6972 6573 2d50 7974 686f  ..Requires-Pytho
 00000100: 6e3a 203e 3d33 2e37 0d0a 4465 7363 7269  n: >=3.7..Descri
 00000110: 7074 696f 6e2d 436f 6e74 656e 742d 5479  ption-Content-Ty
 00000120: 7065 3a20 7465 7874 2f6d 6172 6b64 6f77  pe: text/markdow
 00000130: 6e0d 0a4c 6963 656e 7365 2d46 696c 653a  n..License-File:
 00000140: 204c 4943 454e 5345 0d0a 0d0a 0d0a 0d0a   LICENSE........
-00000150: 2323 2320 5768 6174 2773 2020 5343 2d54  ### What's  SC-T
-00000160: 7261 636b 3f0d 0a0d 0a0d 0a53 432d 5472  rack?......SC-Tr
-00000170: 6163 6b20 6973 2061 6e20 6566 6669 6369  ack is an effici
-00000180: 656e 7420 616c 676f 7269 7468 6d20 666f  ent algorithm fo
-00000190: 7220 6479 6e61 6d69 6320 7472 6163 6b69  r dynamic tracki
-000001a0: 6e67 206f 6620 7369 6e67 6c65 2063 656c  ng of single cel
-000001b0: 6c73 206f 6e20 6469 6666 6572 656e 7420  ls on different 
-000001c0: 7469 6d65 2d6c 6170 7365 206d 6963 726f  time-lapse micro
-000001d0: 7363 6f70 6520 696d 6167 6573 2e20 0d0a  scope images. ..
-000001e0: 4974 2063 616e 2075 7365 2074 6865 2073  It can use the s
-000001f0: 6567 6d65 6e74 6174 696f 6e20 7265 7375  egmentation resu
-00000200: 6c74 7320 6f66 2076 6172 696f 7573 206d  lts of various m
-00000210: 6f64 656c 7320 746f 2065 6666 6963 6965  odels to efficie
-00000220: 6e74 6c79 2074 7261 636b 2073 696e 676c  ntly track singl
-00000230: 6520 6365 6c6c 7320 616e 6420 7265 636f  e cells and reco
-00000240: 6e73 7472 7563 7420 6365 6c6c 206c 696e  nstruct cell lin
-00000250: 6573 2e20 0d0a 4974 2063 616e 2074 7261  es. ..It can tra
-00000260: 636b 206d 756c 7469 2d67 656e 6572 6174  ck multi-generat
-00000270: 696f 6e61 6c20 6365 6c6c 2064 6976 6973  ional cell divis
-00000280: 696f 6e20 6576 656e 7473 2077 6974 686f  ion events witho
-00000290: 7574 2061 6e79 2061 6464 6974 696f 6e61  ut any additiona
-000002a0: 6c20 696e 666f 726d 6174 696f 6e2c 206f  l information, o
-000002b0: 6e6c 7920 7573 696e 6720 7468 6520 6f75  nly using the ou
-000002c0: 746c 696e 6520 696e 666f 726d 6174 696f  tline informatio
-000002d0: 6e20 6f66 2063 656c 6c73 3b20 0d0a 616e  n of cells; ..an
-000002e0: 6420 6361 6e20 7265 6475 6365 2074 6865  d can reduce the
-000002f0: 206e 6f69 7365 206f 6620 7468 6520 7365   noise of the se
-00000300: 676d 656e 7461 7469 6f6e 2c20 736f 2061  gmentation, so a
-00000310: 7320 746f 2075 7365 2074 6865 206e 6f69  s to use the noi
-00000320: 7365 2073 6567 6d65 6e74 6174 696f 6e20  se segmentation 
-00000330: 7265 7375 6c74 7320 746f 2067 656e 6572  results to gener
-00000340: 6174 6520 6163 6375 7261 7465 2063 656c  ate accurate cel
-00000350: 6c20 6c69 6e65 6167 6573 2e20 0d0a 4974  l lineages. ..It
-00000360: 7320 6361 7363 6164 652d 6361 6368 696e  s cascade-cachin
-00000370: 6720 6d6f 6465 6c20 6361 6e20 6566 6669  g model can effi
-00000380: 6369 656e 746c 7920 6465 616c 2077 6974  ciently deal wit
-00000390: 6820 7365 676d 656e 7461 7469 6f6e 206c  h segmentation l
-000003a0: 6f73 732c 2061 6e64 2069 7473 2054 5053  oss, and its TPS
-000003b0: 2061 6c67 6f72 6974 686d 2063 616e 2070   algorithm can p
-000003c0: 6572 666f 726d 2061 6363 7572 6174 6520  erform accurate 
-000003d0: 7265 636c 6173 7369 6669 6361 7469 6f6e  reclassification
-000003e0: 200d 0a66 6f72 2075 7365 7273 2077 6974   ..for users wit
-000003f0: 6820 6365 6c6c 2063 6c61 7373 6966 6963  h cell classific
-00000400: 6174 696f 6e20 6e65 6564 7320 2873 7563  ation needs (suc
-00000410: 6820 6173 2063 6c61 7373 6966 6963 6174  h as classificat
-00000420: 696f 6e20 6f66 2064 6966 6665 7265 6e74  ion of different
-00000430: 2063 656c 6c20 6379 636c 6520 7068 6173   cell cycle phas
-00000440: 6573 292e 200d 0a53 432d 5472 6163 6b20  es). ..SC-Track 
-00000450: 616c 6c6f 7773 2075 7365 7273 2074 6f20  allows users to 
-00000460: 7573 6520 6469 6666 6572 656e 7420 7365  use different se
-00000470: 676d 656e 7461 7469 6f6e 2072 6573 756c  gmentation resul
-00000480: 7473 2061 7320 696e 7075 742c 2069 6e63  ts as input, inc
-00000490: 6c75 6469 6e67 2074 6865 204a 534f 4e20  luding the JSON 
-000004a0: 616e 6e6f 7461 7469 6f6e 2066 696c 6520  annotation file 
-000004b0: 666f 726d 6174 2073 7570 706f 7274 6564  format supported
-000004c0: 2062 7920 5647 4720 696d 6167 6520 616e   by VGG image an
-000004d0: 6e6f 7461 746f 722c 200d 0a61 6e64 2074  notator, ..and t
-000004e0: 6865 2063 6f6d 6d6f 6e20 6d61 736b 2067  he common mask g
-000004f0: 7261 7973 6361 6c65 2069 6d61 6765 2066  rayscale image f
-00000500: 6f72 6d61 742e 2054 6865 2065 7870 6f72  ormat. The expor
-00000510: 7420 7265 7375 6c74 7320 696e 636c 7564  t results includ
-00000520: 6520 7472 6163 6b20 7461 626c 652c 2076  e track table, v
-00000530: 6973 7561 6c69 7a65 6420 6c61 6265 6c65  isualized labele
-00000540: 6420 696d 6167 652c 200d 0a4a 534f 4e20  d image, ..JSON 
-00000550: 6669 6c65 2063 6f6e 7461 696e 696e 6720  file containing 
-00000560: 7472 6163 6b69 6e67 2069 6e66 6f72 6d61  tracking informa
-00000570: 7469 6f6e 2028 7768 6963 6820 6361 6e20  tion (which can 
-00000580: 6265 2069 6d70 6f72 7465 6420 696e 746f  be imported into
-00000590: 2056 4747 2069 6d61 6765 2061 6e6e 6f74   VGG image annot
-000005a0: 6174 6f72 2066 6f72 2076 6965 7769 6e67  ator for viewing
-000005b0: 292c 200d 0a61 6e64 2061 2063 6f6c 6c65  ), ..and a colle
-000005c0: 6374 696f 6e20 6f66 2054 7261 636b 696e  ction of Trackin
-000005d0: 6754 7265 6520 7374 7275 6374 7572 6520  gTree structure 
-000005e0: 7472 6565 2066 696c 6573 2e20 5573 6572  tree files. User
-000005f0: 7320 6361 6e20 7065 7266 6f72 6d20 6d6f  s can perform mo
-00000600: 7265 2064 6574 6169 6c65 6420 646f 776e  re detailed down
-00000610: 7374 7265 616d 2061 6e61 6c79 7369 7320  stream analysis 
-00000620: 6f6e 2074 6865 2074 7261 636b 2074 6162  on the track tab
-00000630: 6c65 2c20 0d0a 7669 6577 2074 6865 2074  le, ..view the t
-00000640: 7261 636b 696e 6720 7265 7375 6c74 7320  racking results 
-00000650: 7468 726f 7567 6820 7669 7375 616c 697a  through visualiz
-00000660: 6564 2072 6573 756c 7473 2c20 616e 6420  ed results, and 
-00000670: 6d6f 6469 6679 2074 6865 2074 7261 636b  modify the track
-00000680: 2074 6162 6c65 206f 7220 7472 6163 6b20   table or track 
-00000690: 6a73 6f6e 2066 696c 6520 746f 206d 616e  json file to man
-000006a0: 7561 6c6c 7920 636f 7272 6563 7420 7472  ually correct tr
-000006b0: 6163 6b69 6e67 2065 7272 6f72 732e 200d  acking errors. .
-000006c0: 0a53 432d 5472 6163 6b20 6973 206e 6f74  .SC-Track is not
-000006d0: 206f 6e6c 7920 7375 6974 6162 6c65 2066   only suitable f
-000006e0: 6f72 2073 6d61 6c6c 2074 696d 656c 6170  or small timelap
-000006f0: 7365 2061 6e61 6c79 7369 732c 2062 7574  se analysis, but
-00000700: 2061 6c73 6f20 7375 6974 6162 6c65 2066   also suitable f
-00000710: 6f72 206c 6f6e 6720 7469 6d65 2061 6e64  or long time and
-00000720: 2068 6967 6820 6365 6c6c 2064 656e 7369   high cell densi
-00000730: 7479 2074 696d 656c 6170 7365 2061 6e61  ty timelapse ana
-00000740: 6c79 7369 7320 6f66 2074 686f 7573 616e  lysis of thousan
-00000750: 6473 206f 6620 6672 616d 6573 2e0d 0a0d  ds of frames....
-00000760: 0a0d 0a0d 0a0d 0a23 2323 2057 6879 2075  .......### Why u
-00000770: 7369 6e67 2020 5343 2d54 7261 636b 3f0d  sing  SC-Track?.
-00000780: 0a0d 0a2d 2020 2054 6865 2063 7572 7265  ...-   The curre
-00000790: 6e74 206d 6169 6e73 7472 6561 6d20 6d65  nt mainstream me
-000007a0: 7468 6f64 7320 666f 7220 696d 6167 6520  thods for image 
-000007b0: 7365 676d 656e 7461 7469 6f6e 2061 6c6c  segmentation all
-000007c0: 2075 7365 2064 6565 7020 6c65 6172 6e69   use deep learni
-000007d0: 6e67 2c20 616e 6420 7468 6520 6f75 7470  ng, and the outp
-000007e0: 7574 2072 6573 756c 7473 2063 6f6e 7461  ut results conta
-000007f0: 696e 206e 6f69 7365 7320 6f66 2076 6172  in noises of var
-00000800: 7969 6e67 2069 6e74 656e 7369 7469 6573  ying intensities
-00000810: 2e20 5343 2d54 7261 636b 2069 7320 6375  . SC-Track is cu
-00000820: 7272 656e 746c 7920 7468 6520 6f6e 6c79  rrently the only
-00000830: 2061 6c67 6f72 6974 686d 2074 6861 7420   algorithm that 
-00000840: 6361 6e20 7573 6520 7468 6573 6520 6e6f  can use these no
-00000850: 6973 6520 6461 7461 2066 6f72 2061 6363  ise data for acc
-00000860: 7572 6174 6520 7369 6e67 6c65 2d63 656c  urate single-cel
-00000870: 6c20 7472 6163 6b69 6e67 2061 6e64 206c  l tracking and l
-00000880: 696e 6561 6765 2072 6563 6f6e 7374 7275  ineage reconstru
-00000890: 6374 696f 6e2e 0d0a 2d20 5343 2d54 7261  ction...- SC-Tra
-000008a0: 636b 2069 7320 636f 6d70 6174 6962 6c65  ck is compatible
-000008b0: 2077 6974 6820 7468 6520 6f75 7470 7574   with the output
-000008c0: 2072 6573 756c 7473 206f 6620 6d6f 7374   results of most
-000008d0: 206f 6620 7468 6520 6578 6973 7469 6e67   of the existing
-000008e0: 206d 6169 6e73 7472 6561 6d20 7365 676d   mainstream segm
-000008f0: 656e 7461 7469 6f6e 206d 6f64 656c 732c  entation models,
-00000900: 2061 7320 7765 6c6c 2061 7320 6d61 6e75   as well as manu
-00000910: 616c 2073 6567 6d65 6e74 6174 696f 6e20  al segmentation 
-00000920: 7265 7375 6c74 732c 2069 6e63 6c75 6469  results, includi
-00000930: 6e67 2043 656c 6c70 6f73 652c 2044 6565  ng Cellpose, Dee
-00000940: 7043 656c 6c2c 2053 7461 7264 6973 742c  pCell, Stardist,
-00000950: 2065 7463 2e20 5573 6572 7320 6361 6e20   etc. Users can 
-00000960: 6368 6f6f 7365 2061 206d 6f72 6520 6164  choose a more ad
-00000970: 7661 6e63 6564 2061 6e64 2073 7569 7461  vanced and suita
-00000980: 626c 6520 7365 676d 656e 7461 7469 6f6e  ble segmentation
-00000990: 206d 6f64 656c 2061 6363 6f72 6469 6e67   model according
-000009a0: 2074 6f20 7468 6520 6365 6c6c 2074 7970   to the cell typ
-000009b0: 6520 746f 2073 706c 6974 2e0d 0a2d 2053  e to split...- S
-000009c0: 432d 5472 6163 6b20 6361 6e20 6566 6669  C-Track can effi
-000009d0: 6369 656e 746c 7920 7472 6163 6b20 6d75  ciently track mu
-000009e0: 6c74 6970 6c65 2074 6172 6765 7473 2062  ltiple targets b
-000009f0: 6574 7765 656e 2066 7261 6d65 7320 7769  etween frames wi
-00000a00: 7468 6f75 7420 7265 6c79 696e 6720 6f6e  thout relying on
-00000a10: 2067 6c6f 6261 6c20 696e 666f 726d 6174   global informat
-00000a20: 696f 6e2c 2061 6e64 2063 616e 2062 6520  ion, and can be 
-00000a30: 7573 6564 2066 6f72 2072 6561 6c2d 7469  used for real-ti
-00000a40: 6d65 2074 7261 636b 696e 672e 0d0a 2d20  me tracking...- 
-00000a50: 5343 2d54 7261 636b 2069 7320 696d 706c  SC-Track is impl
-00000a60: 656d 656e 7465 6420 696e 2050 7974 686f  emented in Pytho
-00000a70: 6e2c 2077 6869 6368 2068 6173 2073 7472  n, which has str
-00000a80: 6f6e 6720 7363 616c 6162 696c 6974 792c  ong scalability,
-00000a90: 2063 6f6e 7665 6e69 656e 7420 616e 6420   convenient and 
-00000aa0: 7175 6963 6b20 696e 7374 616c 6c61 7469  quick installati
-00000ab0: 6f6e 2c20 616e 6420 6c6f 7720 6465 7065  on, and low depe
-00000ac0: 6e64 656e 6379 2e0d 0a0d 0a0d 0a0d 0a23  ndency.........#
-00000ad0: 2323 2048 6f77 2074 6f20 7573 6520 5343  ## How to use SC
-00000ae0: 2d54 7261 636b 3f0d 0a0d 0a60 6060 0d0a  -Track?....```..
-00000af0: 546f 2075 7365 2053 432d 5472 6163 6b2c  To use SC-Track,
-00000b00: 2070 6c65 6173 6520 666f 6c6c 6f77 2074   please follow t
-00000b10: 6865 2049 6e73 7461 6c6c 6174 696f 6e20  he Installation 
-00000b20: 7374 6570 7320 6669 7273 742e 2049 7420  steps first. It 
-00000b30: 646f 6573 206e 6f74 2072 6571 7569 7265  does not require
-00000b40: 2074 6f6f 206d 616e 7920 7365 7474 696e   too many settin
-00000b50: 6773 2064 7572 696e 6720 6974 7320 7573  gs during its us
-00000b60: 652e 2057 6865 6e20 796f 7520 6f6e 6c79  e. When you only
-00000b70: 2068 6176 6520 6120 7369 6e67 6c65 2d63   have a single-c
-00000b80: 6861 6e6e 656c 2073 6567 6d65 6e74 6174  hannel segmentat
-00000b90: 696f 6e20 7265 7375 6c74 2c20 7765 2072  ion result, we r
-00000ba0: 6571 7569 7265 2074 6861 7420 796f 7572  equire that your
-00000bb0: 2073 6567 6d65 6e74 6174 696f 6e20 7265   segmentation re
-00000bc0: 7375 6c74 206d 7573 7420 6265 2061 206d  sult must be a m
-00000bd0: 6173 6b20 6772 6179 7363 616c 6520 6669  ask grayscale fi
-00000be0: 6c65 2069 6e20 7468 6520 666f 726d 206f  le in the form o
-00000bf0: 6620 3244 2b74 2069 6e20 7469 6666 2066  f 2D+t in tiff f
-00000c00: 6f72 6d61 742e 2054 6865 2063 656c 6c73  ormat. The cells
-00000c10: 2069 6e20 6561 6368 206d 6173 6b20 6e65   in each mask ne
-00000c20: 6564 2074 6f20 6775 6172 616e 7465 6520  ed to guarantee 
-00000c30: 7468 6569 7220 7069 7865 6c20 7661 6c75  their pixel valu
-00000c40: 6573 2e20 6973 2075 6e69 7175 653b 206f  es. is unique; o
-00000c50: 7220 6120 4a53 4f4e 2063 6f6d 6d65 6e74  r a JSON comment
-00000c60: 2066 696c 652e 2054 6865 2073 7065 6369   file. The speci
-00000c70: 6669 6320 666f 726d 6174 2063 616e 2072  fic format can r
-00000c80: 6566 6572 2074 6f20 6f75 7220 6578 616d  efer to our exam
-00000c90: 706c 652e 0d0a 0d0a 5768 656e 2074 6865  ple.....When the
-00000ca0: 2073 6567 6d65 6e74 6174 696f 6e20 7265   segmentation re
-00000cb0: 7375 6c74 2069 7320 6120 6d61 736b 2c20  sult is a mask, 
-00000cc0: 706c 6561 7365 2072 756e 3a20 7363 7472  please run: sctr
-00000cd0: 6163 6b20 2d70 2069 6d61 6765 2e74 6966  ack -p image.tif
-00000ce0: 202d 6120 6d61 736b 2e74 6966 2e0d 0a57   -a mask.tif...W
-00000cf0: 6865 6e20 7468 6520 7365 676d 656e 7461  hen the segmenta
-00000d00: 7469 6f6e 2072 6573 756c 7420 6973 2061  tion result is a
-00000d10: 6e20 616e 6e6f 7461 7469 6f6e 206a 736f  n annotation jso
-00000d20: 6e20 6669 6c65 2c20 706c 6561 7365 2072  n file, please r
-00000d30: 756e 3a20 7363 7472 6163 6b20 2d70 2069  un: sctrack -p i
-00000d40: 6d61 6765 2e74 6966 202d 6120 616e 6e6f  mage.tif -a anno
-00000d50: 7461 7469 6f6e 2e6a 736f 6e2e 0d0a 5768  tation.json...Wh
-00000d60: 6572 6520 696d 6167 652e 7469 6620 6973  ere image.tif is
-00000d70: 2074 6865 206f 7269 6769 6e61 6c20 696d   the original im
-00000d80: 6167 652c 206d 6173 6b2e 7469 662c 2061  age, mask.tif, a
-00000d90: 6e64 2061 6e6e 6f74 6174 696f 6e2e 6a73  nd annotation.js
-00000da0: 6f6e 2061 7265 2061 6e6e 6f74 6174 696f  on are annotatio
-00000db0: 6e20 6669 6c65 732e 2054 6865 206f 7269  n files. The ori
-00000dc0: 6769 6e61 6c20 696d 6167 6520 6d61 7920  ginal image may 
-00000dd0: 6e6f 7420 6265 2070 726f 7669 6465 642c  not be provided,
-00000de0: 2062 7574 2069 6620 7468 6520 6f72 6967   but if the orig
-00000df0: 696e 616c 2069 6d61 6765 2069 7320 6e6f  inal image is no
-00000e00: 7420 7072 6f76 6964 6564 2c20 7468 6520  t provided, the 
-00000e10: 7669 7375 616c 697a 6174 696f 6e20 7265  visualization re
-00000e20: 7375 6c74 2063 616e 6e6f 7420 6265 206f  sult cannot be o
-00000e30: 7574 7075 742e 0d0a 6060 600d 0a0d 0a0d  utput...```.....
-00000e40: 0a0d 0a23 2323 2049 6e73 7461 6c6c 6174  ...### Installat
-00000e50: 696f 6e0d 0a0d 0a60 6060 0d0a 5265 7175  ion....```..Requ
-00000e60: 6972 656d 656e 743a 2050 7974 686f 6e20  irement: Python 
-00000e70: 3e3d 2033 2e37 0d0a 0d0a 5769 6e64 6f77  >= 3.7....Window
-00000e80: 733a 2070 6970 2069 736e 7461 6c6c 2053  s: pip isntall S
-00000e90: 432d 5472 6163 6b0d 0a4c 696e 7578 2f4d  C-Track..Linux/M
-00000ea0: 6163 6f73 3a20 7069 7033 2069 736e 7461  acos: pip3 isnta
-00000eb0: 6c6c 2053 432d 5472 6163 6b0d 0a0d 0a60  ll SC-Track....`
-00000ec0: 6060 0d0a 0d0a 2d20 2020 4e6f 7465 efbc  ``....-   Note..
-00000ed0: 9a20 4f6e 2060 5769 6e64 6f77 7360 2c20  . On `Windows`, 
-00000ee0: 7468 6520 7265 7175 6972 656d 656e 7420  the requirement 
-00000ef0: 7061 636b 6167 6520 6070 796c 6962 7469  package `pylibti
-00000f00: 6666 2060 6361 6e6e 6f74 2064 6972 6563  ff `cannot direc
-00000f10: 746c 7920 696e 7374 616c 6c20 6279 2070  tly install by p
-00000f20: 6970 2c20 706c 6561 7365 2069 6e73 7461  ip, please insta
-00000f30: 6c6c 2077 6974 6820 7468 6973 2063 6f6d  ll with this com
-00000f40: 6d61 6e64 3a0d 0a0d 0a20 2020 2060 636f  mand:....    `co
-00000f50: 6e64 6120 696e 7374 616c 6c20 6c69 6274  nda install libt
-00000f60: 6966 6660 0d0a 0d0a 2020 2020 6f72 2079  iff`....    or y
-00000f70: 6f75 2063 616e 2064 6f77 6e6c 6f61 6420  ou can download 
-00000f80: 7468 6520 7768 6565 6c20 7061 636b 6167  the wheel packag
-00000f90: 6520 6672 6f6d 205b 6865 7265 5d28 6874  e from [here](ht
-00000fa0: 7470 733a 2f2f 7777 772e 6c66 642e 7563  tps://www.lfd.uc
-00000fb0: 692e 6564 752f 7e67 6f68 6c6b 652f 7079  i.edu/~gohlke/py
-00000fc0: 7468 6f6e 6c69 6273 2f23 7079 6c69 6274  thonlibs/#pylibt
-00000fd0: 6966 6629 2c20 616e 6420 7468 656e 2075  iff), and then u
-00000fe0: 7369 6e67 2060 7069 7020 696e 7374 616c  sing `pip instal
-00000ff0: 6c20 7079 6c69 6274 6966 662e 7768 6c60  l pylibtiff.whl`
-00001000: 2074 6f20 696e 7374 616c 6c2e 0d0a 0d0a   to install.....
-00001010: 2020 2020 4f6e 2060 4c69 6e75 7860 206f      On `Linux` o
-00001020: 7220 604d 6163 6f73 602c 206a 7573 7420  r `Macos`, just 
-00001030: 7573 696e 6720 6070 6970 2069 6e73 7461  using `pip insta
-00001040: 6c6c 2070 796c 6962 7469 6666 6020 746f  ll pylibtiff` to
-00001050: 2069 6e73 7461 6c6c 2e0d 0a0d 0a0d 0a0d   install........
-00001060: 0a0d 0a0d 0a23 2323 2055 7361 6765 0d0a  .....### Usage..
-00001070: 0d0a 6060 6070 7974 686f 6e0d 0a57 6520  ..```python..We 
-00001080: 7072 6f76 6964 6520 6120 636f 6d6d 616e  provide a comman
-00001090: 6420 6c69 6e65 2074 6f6f 6c2c 2079 6f75  d line tool, you
-000010a0: 206f 6e6c 7920 6e65 6564 2074 6f20 7275   only need to ru
-000010b0: 6e20 7468 6520 7363 7472 6163 6b20 746f  n the sctrack to
-000010c0: 6f6c 206f 6e20 7468 6520 636f 6d6d 616e  ol on the comman
-000010d0: 6420 6c69 6e65 2e20 546f 2061 7574 6f6d  d line. To autom
-000010e0: 6174 6520 6261 7463 6820 7072 6f63 6573  ate batch proces
-000010f0: 7369 6e67 206f 6620 6120 6c61 7267 6520  sing of a large 
-00001100: 6e75 6d62 6572 206f 6620 6669 6c65 732c  number of files,
-00001110: 2070 6c65 6173 6520 7265 6665 7220 746f   please refer to
-00001120: 206f 7572 2073 6f75 7263 6520 636f 6465   our source code
-00001130: 2064 6f63 756d 656e 7461 7469 6f6e 2e0d   documentation..
-00001140: 0a49 7473 2062 6173 6963 2075 7361 6765  .Its basic usage
-00001150: 2069 733a 0d0a 2020 2020 0d0a 6672 6f6d   is:..    ..from
-00001160: 2053 4354 7261 636b 2069 6d70 6f72 7420   SCTrack import 
-00001170: 7374 7261 745f 7472 6163 6b0d 0a0d 0a69  strat_track....i
-00001180: 6d61 6765 203d 2027 7061 7468 2f74 6f2f  mage = 'path/to/
-00001190: 696d 6167 652e 7469 6627 0d0a 0d0a 2320  image.tif'....# 
-000011a0: 7573 696e 6720 6d61 736b 2061 6e6e 6f74  using mask annot
-000011b0: 6174 696f 6e0d 0a61 6e6e 6f74 6174 696f  ation..annotatio
-000011c0: 6e5f 6d61 736b 203d 2027 2f70 6174 682f  n_mask = '/path/
-000011d0: 746f 2f61 6e6e 6f74 6174 696f 6e2e 7469  to/annotation.ti
-000011e0: 6627 0d0a 7374 6172 745f 7472 6163 6b28  f'..start_track(
-000011f0: 6661 6e6e 6f74 6174 696f 6e3d 616e 6e6f  fannotation=anno
-00001200: 7461 7469 6f6e 5f6d 6173 6b2c 2066 696d  tation_mask, fim
-00001210: 6167 653d 696d 6167 6529 0d0a 0d0a 2320  age=image)....# 
-00001220: 7573 696e 6720 6a73 6f6e 2066 696c 6520  using json file 
-00001230: 616e 6e6f 7461 7469 6f6e 0d0a 616e 6e6f  annotation..anno
-00001240: 7461 7469 6f6e 5f6a 736f 6e20 3d20 272f  tation_json = '/
-00001250: 7061 7468 2f74 6f2f 616e 6e6f 7461 7469  path/to/annotati
-00001260: 6f6e 2e6a 736f 6e27 0d0a 7374 6172 745f  on.json'..start_
-00001270: 7472 6163 6b28 6661 6e6e 6f74 6174 696f  track(fannotatio
-00001280: 6e3d 616e 6e6f 7461 7469 6f6e 5f6a 736f  n=annotation_jso
-00001290: 6e2c 2066 696d 6167 653d 696d 6167 6529  n, fimage=image)
-000012a0: 0d0a 6060 600d 0a0d 0a                   ..```....
+00000150: 2323 203c 6469 7620 616c 6967 6e3d 2263  ## <div align="c
+00000160: 656e 7465 7222 2073 7479 6c65 3d22 7465  enter" style="te
+00000170: 7874 2d61 6c69 676e 3a20 6365 6e74 6572  xt-align: center
+00000180: 3b20 666f 6e74 2d73 697a 653a 2033 3270  ; font-size: 32p
+00000190: 783b 223e 203c 623e 3c61 2068 7265 663d  x;"> <b><a href=
+000001a0: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
+000001b0: 6f6d 2f66 726f 7a65 6e6c 6561 7665 732f  om/frozenleaves/
+000001c0: 5343 2d54 7261 636b 3e53 432d 5472 6163  SC-Track>SC-Trac
+000001d0: 6b20 3a20 2054 7261 636b 696e 6720 2066  k :  Tracking  f
+000001e0: 6f72 2020 5369 6e67 6c65 2020 4365 6c6c  or  Single  Cell
+000001f0: 3c2f 613e 3c2f 623e 3c2f 6469 763e 0d0a  </a></b></div>..
+00000200: 0d0a 3c64 6976 2061 6c69 676e 3d22 6365  ..<div align="ce
+00000210: 6e74 6572 223e 203c 696d 6720 7372 633d  nter"> <img src=
+00000220: 2264 6f63 732f 6963 6f6e 2f6c 6963 656e  "docs/icon/licen
+00000230: 7365 2e73 7667 2220 7769 6474 6820 3d20  se.svg" width = 
+00000240: 3232 3020 2f3e 203c 696d 6720 7372 633d  220 /> <img src=
+00000250: 2264 6f63 732f 6963 6f6e 2f77 6865 656c  "docs/icon/wheel
+00000260: 2e73 7667 2220 7769 6474 6820 3d20 3730  .svg" width = 70
+00000270: 202f 3e20 203c 696d 6720 7372 633d 2264   />  <img src="d
+00000280: 6f63 732f 6963 6f6e 2f64 6f63 732e 7376  ocs/icon/docs.sv
+00000290: 6722 2077 6964 7468 203d 2038 3020 2f3e  g" width = 80 />
+000002a0: 203c 696d 6720 7372 633d 2264 6f63 732f   <img src="docs/
+000002b0: 6963 6f6e 2f50 7974 686f 6e2d 7665 7273  icon/Python-vers
+000002c0: 696f 6e2e 7376 6722 2077 6964 7468 203d  ion.svg" width =
+000002d0: 2032 3030 202f 3e20 3c2f 6469 763e 200d   200 /> </div> .
+000002e0: 0a0d 0a23 2323 2057 6861 7427 7320 2053  ...### What's  S
+000002f0: 432d 5472 6163 6b3f 0d0a 0d0a 5343 2d54  C-Track?....SC-T
+00000300: 7261 636b 2069 7320 616e 2065 6666 6963  rack is an effic
+00000310: 6965 6e74 2061 6c67 6f72 6974 686d 2066  ient algorithm f
+00000320: 6f72 2064 796e 616d 6963 2074 7261 636b  or dynamic track
+00000330: 696e 6720 6f66 2073 696e 676c 6520 6365  ing of single ce
+00000340: 6c6c 7320 6f6e 2064 6966 6665 7265 6e74  lls on different
+00000350: 2074 696d 652d 6c61 7073 6520 6d69 6372   time-lapse micr
+00000360: 6f73 636f 7065 2069 6d61 6765 732e 200d  oscope images. .
+00000370: 0a49 7420 6361 6e20 7573 6520 7468 6520  .It can use the 
+00000380: 7365 676d 656e 7461 7469 6f6e 2072 6573  segmentation res
+00000390: 756c 7473 206f 6620 7661 7269 6f75 7320  ults of various 
+000003a0: 6d6f 6465 6c73 2074 6f20 6566 6669 6369  models to effici
+000003b0: 656e 746c 7920 7472 6163 6b20 7369 6e67  ently track sing
+000003c0: 6c65 2063 656c 6c73 2061 6e64 2072 6563  le cells and rec
+000003d0: 6f6e 7374 7275 6374 2063 656c 6c20 6c69  onstruct cell li
+000003e0: 6e65 732e 200d 0a49 7420 6361 6e20 7472  nes. ..It can tr
+000003f0: 6163 6b20 6d75 6c74 692d 6765 6e65 7261  ack multi-genera
+00000400: 7469 6f6e 616c 2063 656c 6c20 6469 7669  tional cell divi
+00000410: 7369 6f6e 2065 7665 6e74 7320 7769 7468  sion events with
+00000420: 6f75 7420 616e 7920 6164 6469 7469 6f6e  out any addition
+00000430: 616c 2069 6e66 6f72 6d61 7469 6f6e 2c20  al information, 
+00000440: 6f6e 6c79 2075 7369 6e67 2074 6865 206f  only using the o
+00000450: 7574 6c69 6e65 2069 6e66 6f72 6d61 7469  utline informati
+00000460: 6f6e 206f 6620 6365 6c6c 733b 200d 0a61  on of cells; ..a
+00000470: 6e64 2063 616e 2072 6564 7563 6520 7468  nd can reduce th
+00000480: 6520 6e6f 6973 6520 6f66 2074 6865 2073  e noise of the s
+00000490: 6567 6d65 6e74 6174 696f 6e2c 2073 6f20  egmentation, so 
+000004a0: 6173 2074 6f20 7573 6520 7468 6520 6e6f  as to use the no
+000004b0: 6973 6520 7365 676d 656e 7461 7469 6f6e  ise segmentation
+000004c0: 2072 6573 756c 7473 2074 6f20 6765 6e65   results to gene
+000004d0: 7261 7465 2061 6363 7572 6174 6520 6365  rate accurate ce
+000004e0: 6c6c 206c 696e 6561 6765 732e 200d 0a49  ll lineages. ..I
+000004f0: 7473 2063 6173 6361 6465 2d63 6163 6869  ts cascade-cachi
+00000500: 6e67 206d 6f64 656c 2063 616e 2065 6666  ng model can eff
+00000510: 6963 6965 6e74 6c79 2064 6561 6c20 7769  iciently deal wi
+00000520: 7468 2073 6567 6d65 6e74 6174 696f 6e20  th segmentation 
+00000530: 6c6f 7373 2c20 616e 6420 6974 7320 5450  loss, and its TP
+00000540: 5320 616c 676f 7269 7468 6d20 6361 6e20  S algorithm can 
+00000550: 7065 7266 6f72 6d20 6163 6375 7261 7465  perform accurate
+00000560: 2072 6563 6c61 7373 6966 6963 6174 696f   reclassificatio
+00000570: 6e20 0d0a 666f 7220 7573 6572 7320 7769  n ..for users wi
+00000580: 7468 2063 656c 6c20 636c 6173 7369 6669  th cell classifi
+00000590: 6361 7469 6f6e 206e 6565 6473 2028 7375  cation needs (su
+000005a0: 6368 2061 7320 636c 6173 7369 6669 6361  ch as classifica
+000005b0: 7469 6f6e 206f 6620 6469 6666 6572 656e  tion of differen
+000005c0: 7420 6365 6c6c 2063 7963 6c65 2070 6861  t cell cycle pha
+000005d0: 7365 7329 2e20 0d0a 5343 2d54 7261 636b  ses). ..SC-Track
+000005e0: 2061 6c6c 6f77 7320 7573 6572 7320 746f   allows users to
+000005f0: 2075 7365 2064 6966 6665 7265 6e74 2073   use different s
+00000600: 6567 6d65 6e74 6174 696f 6e20 7265 7375  egmentation resu
+00000610: 6c74 7320 6173 2069 6e70 7574 2c20 696e  lts as input, in
+00000620: 636c 7564 696e 6720 7468 6520 4a53 4f4e  cluding the JSON
+00000630: 2061 6e6e 6f74 6174 696f 6e20 6669 6c65   annotation file
+00000640: 2066 6f72 6d61 7420 7375 7070 6f72 7465   format supporte
+00000650: 6420 6279 2056 4747 2069 6d61 6765 2061  d by VGG image a
+00000660: 6e6e 6f74 6174 6f72 2c20 0d0a 616e 6420  nnotator, ..and 
+00000670: 7468 6520 636f 6d6d 6f6e 206d 6173 6b20  the common mask 
+00000680: 6772 6179 7363 616c 6520 696d 6167 6520  grayscale image 
+00000690: 666f 726d 6174 2e20 5468 6520 6578 706f  format. The expo
+000006a0: 7274 2072 6573 756c 7473 2069 6e63 6c75  rt results inclu
+000006b0: 6465 2074 7261 636b 2074 6162 6c65 2c20  de track table, 
+000006c0: 7669 7375 616c 697a 6564 206c 6162 656c  visualized label
+000006d0: 6564 2069 6d61 6765 2c20 0d0a 4a53 4f4e  ed image, ..JSON
+000006e0: 2066 696c 6520 636f 6e74 6169 6e69 6e67   file containing
+000006f0: 2074 7261 636b 696e 6720 696e 666f 726d   tracking inform
+00000700: 6174 696f 6e20 2877 6869 6368 2063 616e  ation (which can
+00000710: 2062 6520 696d 706f 7274 6564 2069 6e74   be imported int
+00000720: 6f20 5647 4720 696d 6167 6520 616e 6e6f  o VGG image anno
+00000730: 7461 746f 7220 666f 7220 7669 6577 696e  tator for viewin
+00000740: 6729 2c20 0d0a 616e 6420 6120 636f 6c6c  g), ..and a coll
+00000750: 6563 7469 6f6e 206f 6620 5472 6163 6b69  ection of Tracki
+00000760: 6e67 5472 6565 2073 7472 7563 7475 7265  ngTree structure
+00000770: 2074 7265 6520 6669 6c65 732e 2055 7365   tree files. Use
+00000780: 7273 2063 616e 2070 6572 666f 726d 206d  rs can perform m
+00000790: 6f72 6520 6465 7461 696c 6564 2064 6f77  ore detailed dow
+000007a0: 6e73 7472 6561 6d20 616e 616c 7973 6973  nstream analysis
+000007b0: 206f 6e20 7468 6520 7472 6163 6b20 7461   on the track ta
+000007c0: 626c 652c 200d 0a76 6965 7720 7468 6520  ble, ..view the 
+000007d0: 7472 6163 6b69 6e67 2072 6573 756c 7473  tracking results
+000007e0: 2074 6872 6f75 6768 2076 6973 7561 6c69   through visuali
+000007f0: 7a65 6420 7265 7375 6c74 732c 2061 6e64  zed results, and
+00000800: 206d 6f64 6966 7920 7468 6520 7472 6163   modify the trac
+00000810: 6b20 7461 626c 6520 6f72 2074 7261 636b  k table or track
+00000820: 206a 736f 6e20 6669 6c65 2074 6f20 6d61   json file to ma
+00000830: 6e75 616c 6c79 2063 6f72 7265 6374 2074  nually correct t
+00000840: 7261 636b 696e 6720 6572 726f 7273 2e20  racking errors. 
+00000850: 0d0a 5343 2d54 7261 636b 2069 7320 6e6f  ..SC-Track is no
+00000860: 7420 6f6e 6c79 2073 7569 7461 626c 6520  t only suitable 
+00000870: 666f 7220 736d 616c 6c20 7469 6d65 6c61  for small timela
+00000880: 7073 6520 616e 616c 7973 6973 2c20 6275  pse analysis, bu
+00000890: 7420 616c 736f 2073 7569 7461 626c 6520  t also suitable 
+000008a0: 666f 7220 6c6f 6e67 2074 696d 6520 616e  for long time an
+000008b0: 6420 6869 6768 2063 656c 6c20 6465 6e73  d high cell dens
+000008c0: 6974 7920 7469 6d65 6c61 7073 6520 616e  ity timelapse an
+000008d0: 616c 7973 6973 206f 6620 7468 6f75 7361  alysis of thousa
+000008e0: 6e64 7320 6f66 2066 7261 6d65 732e 0d0a  nds of frames...
+000008f0: 0d0a 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 0d0a  ..----------....
+00000900: 0d0a 2323 2320 5768 7920 7573 696e 6720  ..### Why using 
+00000910: 2053 432d 5472 6163 6b3f 0d0a 0d0a 2d20   SC-Track?....- 
+00000920: 2020 5468 6520 6375 7272 656e 7420 6d61    The current ma
+00000930: 696e 7374 7265 616d 206d 6574 686f 6473  instream methods
+00000940: 2066 6f72 2069 6d61 6765 2073 6567 6d65   for image segme
+00000950: 6e74 6174 696f 6e20 616c 6c20 7573 6520  ntation all use 
+00000960: 6465 6570 206c 6561 726e 696e 672c 2061  deep learning, a
+00000970: 6e64 2074 6865 206f 7574 7075 7420 7265  nd the output re
+00000980: 7375 6c74 7320 636f 6e74 6169 6e20 6e6f  sults contain no
+00000990: 6973 6573 206f 6620 7661 7279 696e 6720  ises of varying 
+000009a0: 696e 7465 6e73 6974 6965 732e 2053 432d  intensities. SC-
+000009b0: 5472 6163 6b20 6973 2063 7572 7265 6e74  Track is current
+000009c0: 6c79 2074 6865 206f 6e6c 7920 616c 676f  ly the only algo
+000009d0: 7269 7468 6d20 7468 6174 2063 616e 2075  rithm that can u
+000009e0: 7365 2074 6865 7365 206e 6f69 7365 2064  se these noise d
+000009f0: 6174 6120 666f 7220 6163 6375 7261 7465  ata for accurate
+00000a00: 2073 696e 676c 652d 6365 6c6c 2074 7261   single-cell tra
+00000a10: 636b 696e 6720 616e 6420 6c69 6e65 6167  cking and lineag
+00000a20: 6520 7265 636f 6e73 7472 7563 7469 6f6e  e reconstruction
+00000a30: 2e0d 0a2d 2053 432d 5472 6163 6b20 6973  ...- SC-Track is
+00000a40: 2063 6f6d 7061 7469 626c 6520 7769 7468   compatible with
+00000a50: 2074 6865 206f 7574 7075 7420 7265 7375   the output resu
+00000a60: 6c74 7320 6f66 206d 6f73 7420 6f66 2074  lts of most of t
+00000a70: 6865 2065 7869 7374 696e 6720 6d61 696e  he existing main
+00000a80: 7374 7265 616d 2073 6567 6d65 6e74 6174  stream segmentat
+00000a90: 696f 6e20 6d6f 6465 6c73 2c20 6173 2077  ion models, as w
+00000aa0: 656c 6c20 6173 206d 616e 7561 6c20 7365  ell as manual se
+00000ab0: 676d 656e 7461 7469 6f6e 2072 6573 756c  gmentation resul
+00000ac0: 7473 2c20 696e 636c 7564 696e 6720 4365  ts, including Ce
+00000ad0: 6c6c 706f 7365 2c20 4465 6570 4365 6c6c  llpose, DeepCell
+00000ae0: 2c20 5374 6172 6469 7374 2c20 6574 632e  , Stardist, etc.
+00000af0: 2055 7365 7273 2063 616e 2063 686f 6f73   Users can choos
+00000b00: 6520 6120 6d6f 7265 2061 6476 616e 6365  e a more advance
+00000b10: 6420 616e 6420 7375 6974 6162 6c65 2073  d and suitable s
+00000b20: 6567 6d65 6e74 6174 696f 6e20 6d6f 6465  egmentation mode
+00000b30: 6c20 6163 636f 7264 696e 6720 746f 2074  l according to t
+00000b40: 6865 2063 656c 6c20 7479 7065 2074 6f20  he cell type to 
+00000b50: 7370 6c69 742e 0d0a 2d20 5343 2d54 7261  split...- SC-Tra
+00000b60: 636b 2063 616e 2065 6666 6963 6965 6e74  ck can efficient
+00000b70: 6c79 2074 7261 636b 206d 756c 7469 706c  ly track multipl
+00000b80: 6520 7461 7267 6574 7320 6265 7477 6565  e targets betwee
+00000b90: 6e20 6672 616d 6573 2077 6974 686f 7574  n frames without
+00000ba0: 2072 656c 7969 6e67 206f 6e20 676c 6f62   relying on glob
+00000bb0: 616c 2069 6e66 6f72 6d61 7469 6f6e 2c20  al information, 
+00000bc0: 616e 6420 6361 6e20 6265 2075 7365 6420  and can be used 
+00000bd0: 666f 7220 7265 616c 2d74 696d 6520 7472  for real-time tr
+00000be0: 6163 6b69 6e67 2e0d 0a2d 2053 432d 5472  acking...- SC-Tr
+00000bf0: 6163 6b20 6973 2069 6d70 6c65 6d65 6e74  ack is implement
+00000c00: 6564 2069 6e20 5079 7468 6f6e 2c20 7768  ed in Python, wh
+00000c10: 6963 6820 6861 7320 7374 726f 6e67 2073  ich has strong s
+00000c20: 6361 6c61 6269 6c69 7479 2c20 636f 6e76  calability, conv
+00000c30: 656e 6965 6e74 2061 6e64 2071 7569 636b  enient and quick
+00000c40: 2069 6e73 7461 6c6c 6174 696f 6e2c 2061   installation, a
+00000c50: 6e64 206c 6f77 2064 6570 656e 6465 6e63  nd low dependenc
+00000c60: 792e 0d0a 0d0a 0d0a 0d0a 2d2d 2d2d 2d2d  y.........------
+00000c70: 2d0d 0a0d 0a23 2323 2048 6f77 2074 6f20  -....### How to 
+00000c80: 7573 6520 5343 2d54 7261 636b 3f0d 0a0d  use SC-Track?...
+00000c90: 0a60 6060 6d61 726b 646f 776e 0d0a 546f  .```markdown..To
+00000ca0: 2075 7365 2053 432d 5472 6163 6b2c 2070   use SC-Track, p
+00000cb0: 6c65 6173 6520 666f 6c6c 6f77 2074 6865  lease follow the
+00000cc0: 2049 6e73 7461 6c6c 6174 696f 6e20 7374   Installation st
+00000cd0: 6570 7320 6669 7273 742e 2049 7420 646f  eps first. It do
+00000ce0: 6573 206e 6f74 2072 6571 7569 7265 2074  es not require t
+00000cf0: 6f6f 206d 616e 7920 7365 7474 696e 6773  oo many settings
+00000d00: 2064 7572 696e 6720 6974 7320 7573 652e   during its use.
+00000d10: 2057 6865 6e20 796f 7520 6f6e 6c79 2068   When you only h
+00000d20: 6176 6520 6120 0d0a 0d0a 7369 6e67 6c65  ave a ....single
+00000d30: 2d63 6861 6e6e 656c 2073 6567 6d65 6e74  -channel segment
+00000d40: 6174 696f 6e20 7265 7375 6c74 2c20 7765  ation result, we
+00000d50: 2072 6571 7569 7265 2074 6861 7420 796f   require that yo
+00000d60: 7572 2073 6567 6d65 6e74 6174 696f 6e20  ur segmentation 
+00000d70: 7265 7375 6c74 206d 7573 7420 6265 2061  result must be a
+00000d80: 206d 6173 6b20 6772 6179 7363 616c 6520   mask grayscale 
+00000d90: 6669 6c65 2069 6e20 7468 6520 666f 726d  file in the form
+00000da0: 206f 6620 3244 2b74 2069 6e20 0d0a 0d0a   of 2D+t in ....
+00000db0: 7469 6666 2066 6f72 6d61 742e 2054 6865  tiff format. The
+00000dc0: 2063 656c 6c73 2069 6e20 6561 6368 206d   cells in each m
+00000dd0: 6173 6b20 6e65 6564 2074 6f20 6775 6172  ask need to guar
+00000de0: 616e 7465 6520 7468 6569 7220 7069 7865  antee their pixe
+00000df0: 6c20 7661 6c75 6573 2e20 6973 2075 6e69  l values. is uni
+00000e00: 7175 653b 206f 7220 6120 4a53 4f4e 2063  que; or a JSON c
+00000e10: 6f6d 6d65 6e74 2066 696c 652e 2054 6865  omment file. The
+00000e20: 2073 7065 6369 6669 6320 666f 726d 6174   specific format
+00000e30: 2063 616e 200d 0a0d 0a72 6566 6572 2074   can ....refer t
+00000e40: 6f20 6f75 7220 6578 616d 706c 652e 0d0a  o our example...
+00000e50: 0d0a 5768 656e 2074 6865 2073 6567 6d65  ..When the segme
+00000e60: 6e74 6174 696f 6e20 7265 7375 6c74 2069  ntation result i
+00000e70: 7320 6120 6d61 736b 2c20 706c 6561 7365  s a mask, please
+00000e80: 2072 756e 3a20 6073 6374 7261 636b 202d   run: `sctrack -
+00000e90: 7020 696d 6167 652e 7469 6620 2d61 206d  p image.tif -a m
+00000ea0: 6173 6b2e 7469 6660 2e0d 0a57 6865 6e20  ask.tif`...When 
+00000eb0: 7468 6520 7365 676d 656e 7461 7469 6f6e  the segmentation
+00000ec0: 2072 6573 756c 7420 6973 2061 6e20 616e   result is an an
+00000ed0: 6e6f 7461 7469 6f6e 206a 736f 6e20 6669  notation json fi
+00000ee0: 6c65 2c20 706c 6561 7365 2072 756e 3a20  le, please run: 
+00000ef0: 6073 6374 7261 636b 202d 7020 696d 6167  `sctrack -p imag
+00000f00: 652e 7469 6620 2d61 2061 6e6e 6f74 6174  e.tif -a annotat
+00000f10: 696f 6e2e 6a73 6f6e 602e 0d0a 5768 6572  ion.json`...Wher
+00000f20: 6520 696d 6167 652e 7469 6620 6973 2074  e image.tif is t
+00000f30: 6865 206f 7269 6769 6e61 6c20 696d 6167  he original imag
+00000f40: 652c 206d 6173 6b2e 7469 662c 2061 6e64  e, mask.tif, and
+00000f50: 2061 6e6e 6f74 6174 696f 6e2e 6a73 6f6e   annotation.json
+00000f60: 2061 7265 2061 6e6e 6f74 6174 696f 6e20   are annotation 
+00000f70: 6669 6c65 732e 2054 6865 206f 7269 6769  files. The origi
+00000f80: 6e61 6c20 696d 6167 6520 6d61 7920 6e6f  nal image may no
+00000f90: 7420 6265 2070 726f 7669 6465 642c 200d  t be provided, .
+00000fa0: 0a62 7574 2069 6620 7468 6520 6f72 6967  .but if the orig
+00000fb0: 696e 616c 2069 6d61 6765 2069 7320 6e6f  inal image is no
+00000fc0: 7420 7072 6f76 6964 6564 2c20 7468 6520  t provided, the 
+00000fd0: 7669 7375 616c 697a 6174 696f 6e20 7265  visualization re
+00000fe0: 7375 6c74 2063 616e 6e6f 7420 6265 206f  sult cannot be o
+00000ff0: 7574 7075 742e 0d0a 6060 600d 0a0d 0a0d  utput...```.....
+00001000: 0a0d 0a2d 2d2d 2d2d 2d2d 2d2d 2d0d 0a0d  ...----------...
+00001010: 0a23 2323 2049 6e73 7461 6c6c 6174 696f  .### Installatio
+00001020: 6e0d 0a0d 0a60 6060 0d0a 5265 7175 6972  n....```..Requir
+00001030: 656d 656e 743a 2050 7974 686f 6e20 3e3d  ement: Python >=
+00001040: 2033 2e37 0d0a 0d0a 5769 6e64 6f77 733a   3.7....Windows:
+00001050: 2070 6970 2069 736e 7461 6c6c 2053 432d   pip isntall SC-
+00001060: 5472 6163 6b0d 0a4c 696e 7578 2f4d 6163  Track..Linux/Mac
+00001070: 6f73 3a20 7069 7033 2069 736e 7461 6c6c  os: pip3 isntall
+00001080: 2053 432d 5472 6163 6b0d 0a60 6060 0d0a   SC-Track..```..
+00001090: 0d0a 2d20 2020 4e6f 7465 efbc 9a20 4f6e  ..-   Note... On
+000010a0: 2060 5769 6e64 6f77 7360 2c20 7468 6520   `Windows`, the 
+000010b0: 7265 7175 6972 656d 656e 7420 7061 636b  requirement pack
+000010c0: 6167 6520 6070 796c 6962 7469 6666 2060  age `pylibtiff `
+000010d0: 6361 6e6e 6f74 2064 6972 6563 746c 7920  cannot directly 
+000010e0: 696e 7374 616c 6c20 6279 2070 6970 2c20  install by pip, 
+000010f0: 706c 6561 7365 2069 6e73 7461 6c6c 2077  please install w
+00001100: 6974 6820 7468 6973 2063 6f6d 6d61 6e64  ith this command
+00001110: 3a0d 0a0d 0a20 2020 2060 636f 6e64 6120  :....    `conda 
+00001120: 696e 7374 616c 6c20 6c69 6274 6966 6660  install libtiff`
+00001130: 0d0a 0d0a 2020 2020 6f72 2079 6f75 2063  ....    or you c
+00001140: 616e 2064 6f77 6e6c 6f61 6420 7468 6520  an download the 
+00001150: 7768 6565 6c20 7061 636b 6167 6520 6672  wheel package fr
+00001160: 6f6d 205b 6865 7265 5d28 6874 7470 733a  om [here](https:
+00001170: 2f2f 7777 772e 6c66 642e 7563 692e 6564  //www.lfd.uci.ed
+00001180: 752f 7e67 6f68 6c6b 652f 7079 7468 6f6e  u/~gohlke/python
+00001190: 6c69 6273 2f23 7079 6c69 6274 6966 6629  libs/#pylibtiff)
+000011a0: 2c20 616e 6420 7468 656e 2075 7369 6e67  , and then using
+000011b0: 2060 7069 7020 696e 7374 616c 6c20 7079   `pip install py
+000011c0: 6c69 6274 6966 662e 7768 6c60 2074 6f20  libtiff.whl` to 
+000011d0: 696e 7374 616c 6c2e 0d0a 0d0a 2020 2020  install.....    
+000011e0: 4f6e 2060 4c69 6e75 7860 206f 7220 604d  On `Linux` or `M
+000011f0: 6163 6f73 602c 206a 7573 7420 7573 696e  acos`, just usin
+00001200: 6720 6070 6970 2069 6e73 7461 6c6c 2070  g `pip install p
+00001210: 796c 6962 7469 6666 6020 746f 2069 6e73  ylibtiff` to ins
+00001220: 7461 6c6c 2e0d 0a0d 0a0d 0a0d 0a2d 2d2d  tall.........---
+00001230: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001240: 2d2d 2d2d 0d0a 0d0a 2323 2320 5573 6167  ----....### Usag
+00001250: 650d 0a0d 0a60 6060 7079 7468 6f6e 0d0a  e....```python..
+00001260: 5765 2070 726f 7669 6465 2061 2063 6f6d  We provide a com
+00001270: 6d61 6e64 206c 696e 6520 746f 6f6c 2c20  mand line tool, 
+00001280: 796f 7520 6f6e 6c79 206e 6565 6420 746f  you only need to
+00001290: 2072 756e 2074 6865 2073 6374 7261 636b   run the sctrack
+000012a0: 2074 6f6f 6c20 6f6e 2074 6865 2063 6f6d   tool on the com
+000012b0: 6d61 6e64 206c 696e 652e 2054 6f20 6175  mand line. To au
+000012c0: 746f 6d61 7465 200d 0a62 6174 6368 2070  tomate ..batch p
+000012d0: 726f 6365 7373 696e 6720 6f66 2061 206c  rocessing of a l
+000012e0: 6172 6765 206e 756d 6265 7220 6f66 2066  arge number of f
+000012f0: 696c 6573 2c20 706c 6561 7365 2072 6566  iles, please ref
+00001300: 6572 2074 6f20 6f75 7220 736f 7572 6365  er to our source
+00001310: 2063 6f64 6520 646f 6375 6d65 6e74 6174   code documentat
+00001320: 696f 6e2e 0d0a 4974 7320 6261 7369 6320  ion...Its basic 
+00001330: 7573 6167 6520 6973 3a0d 0a20 2020 200d  usage is:..    .
+00001340: 0a66 726f 6d20 5343 5472 6163 6b20 696d  .from SCTrack im
+00001350: 706f 7274 2073 7472 6174 5f74 7261 636b  port strat_track
+00001360: 0d0a 0d0a 696d 6167 6520 3d20 2770 6174  ....image = 'pat
+00001370: 682f 746f 2f69 6d61 6765 2e74 6966 270d  h/to/image.tif'.
+00001380: 0a0d 0a23 2075 7369 6e67 206d 6173 6b20  ...# using mask 
+00001390: 616e 6e6f 7461 7469 6f6e 0d0a 616e 6e6f  annotation..anno
+000013a0: 7461 7469 6f6e 5f6d 6173 6b20 3d20 272f  tation_mask = '/
+000013b0: 7061 7468 2f74 6f2f 616e 6e6f 7461 7469  path/to/annotati
+000013c0: 6f6e 2e74 6966 270d 0a73 7461 7274 5f74  on.tif'..start_t
+000013d0: 7261 636b 2866 616e 6e6f 7461 7469 6f6e  rack(fannotation
+000013e0: 3d61 6e6e 6f74 6174 696f 6e5f 6d61 736b  =annotation_mask
+000013f0: 2c20 6669 6d61 6765 3d69 6d61 6765 290d  , fimage=image).
+00001400: 0a0d 0a23 2075 7369 6e67 206a 736f 6e20  ...# using json 
+00001410: 6669 6c65 2061 6e6e 6f74 6174 696f 6e0d  file annotation.
+00001420: 0a61 6e6e 6f74 6174 696f 6e5f 6a73 6f6e  .annotation_json
+00001430: 203d 2027 2f70 6174 682f 746f 2f61 6e6e   = '/path/to/ann
+00001440: 6f74 6174 696f 6e2e 6a73 6f6e 270d 0a73  otation.json'..s
+00001450: 7461 7274 5f74 7261 636b 2866 616e 6e6f  tart_track(fanno
+00001460: 7461 7469 6f6e 3d61 6e6e 6f74 6174 696f  tation=annotatio
+00001470: 6e5f 6a73 6f6e 2c20 6669 6d61 6765 3d69  n_json, fimage=i
+00001480: 6d61 6765 290d 0a60 6060 0d0a 0d0a 0d0a  mage)..```......
+00001490: 0d0a 2d2d 2d2d 2d2d 0d0a 0d0a 2323 2320  ..------....### 
+000014a0: 4150 4920 2044 6f63 756d 656e 7461 7469  API  Documentati
+000014b0: 6f6e 0d0a 0d0a 466f 7220 6d6f 7265 2069  on....For more i
+000014c0: 6e66 6f72 6d61 7469 6f6e 2c20 706c 6561  nformation, plea
+000014d0: 7365 2073 6565 2074 6865 205b 7265 6665  se see the [refe
+000014e0: 7265 6e63 6520 646f 6375 6d65 6e74 735d  rence documents]
+000014f0: 2868 7474 7073 3a2f 2f73 632d 7472 6163  (https://sc-trac
+00001500: 6b2e 7265 6164 7468 6564 6f63 732e 696f  k.readthedocs.io
+00001510: 2f65 6e2f 6c61 7465 7374 2f29 2e0d 0a0d  /en/latest/)....
+00001520: 0a0d 0a0d 0a                             .....
```

### Comparing `SC-Track-0.0.4/setup.py` & `SC-Track-0.0.5/setup.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     long_description = f.read()
 
 with open('requirements.txt', 'r') as fr:
     pkg_requirements = fr.read().split('\n')
     pkg_requirements.remove('')
 
 
-VERSION = '0.0.4'
+VERSION = '0.0.5'
 
 setuptools.setup(
     name='SC-Track',
     author="Li Chengxin",
     author_email="914814442@qq.com",
     url="https://github.com/frozenleaves/SC-Track",
     license="GNU General Public License v3.0",
```

